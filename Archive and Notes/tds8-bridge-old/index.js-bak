#!/usr/bin/env node
// TDS-8 Desktop Bridge ‚Äî comm toggle (wired|wifi), Wi-Fi scan (Windows), batch tracks, firmware feed + manifest

const path = require('path');
const fs = require('fs');
const express = require('express');
const morgan = require('morgan');
const http = require('http');
const WebSocket = require('ws');
const osc = require('osc');
const { exec } = require('child_process');
const { SerialPortStream } = require('@serialport/stream');
const { autoDetect } = require('@serialport/bindings-cpp');

const PORT = process.env.PORT || 8088;
const OSC_LISTEN_PORT = parseInt(process.env.OSC_LISTEN_PORT || '8003', 10);  // Changed to 8003 to avoid blocking
const OSC_LISTEN_PORT_ALT = parseInt(process.env.OSC_LISTEN_PORT_ALT || '8000', 10); // Compat: some templates use 8000
const BAUD = parseInt(process.env.BAUD || '115200', 10);

// Optional defaults (you can set these later)
const OTA_MANIFEST_URL = process.env.OTA_MANIFEST_URL || '';
const FW_FEED_URL = process.env.FW_FEED_URL || '';

const Bindings = autoDetect();

// Multi-device support: Store up to 4 TDS-8 devices
const MAX_DEVICES = 4;
let devices = []; // Array of { id, serial, path, buffer, version, deviceID, serialNumber, connectionMode, ip }
// Dedupe map: per-device last command and timestamp to prevent double sends
const lastSendMap = new Map(); // deviceId -> { cmd: string, at: number }
// Rate-limit map for /ableton_on announcements per device
const lastAbletonOnAt = new Map(); // deviceId -> timestamp
// Track-level dedupe: key `${deviceId}:${globalTrack}` -> { name: string, at: number }
const trackSendMap = new Map();

// Global pacing between any two commands (70ms default)
const SEND_GAP_MS = parseInt(process.env.SEND_GAP_MS || '70', 10);
const sendQueue = [];
let isProcessingSends = false;
let lastSendAtGlobal = 0;

async function processSendQueue() {
  if (isProcessingSends) return;
  isProcessingSends = true;
  try {
    while (sendQueue.length > 0) {
      const waitMs = Math.max(0, SEND_GAP_MS - (Date.now() - lastSendAtGlobal));
      if (waitMs > 0) {
        await new Promise(r => setTimeout(r, waitMs));
      }
      const item = sendQueue.shift();
      try {
        sendToDeviceImmediate(item.deviceId, item.s, item.origin);
      } catch (e) {
        console.error('‚ùå Queue send error:', e.message);
      }
      lastSendAtGlobal = Date.now();
    }
  } finally {
    isProcessingSends = false;
  }
}

function enqueueSendToDevice(deviceId, s, origin = 'unknown') {
  sendQueue.push({ deviceId, s, origin });
  processSendQueue();
}

// Persisted device ID mapping by hardware serial number
const DEVICE_ID_MAP_PATH = path.join(__dirname, 'device_ids.json');
let deviceIdMap = new Map(); // serialNumber -> deviceId
function loadDeviceIdMap() {
  try {
    const raw = fs.readFileSync(DEVICE_ID_MAP_PATH, 'utf8');
    const obj = JSON.parse(raw);
    deviceIdMap = new Map(Object.entries(obj));
    // Values may be strings; normalize to numbers
    for (const [k, v] of deviceIdMap) deviceIdMap.set(k, typeof v === 'number' ? v : parseInt(v, 10));
    console.log(`üì• Loaded deviceIdMap:`, Object.fromEntries(deviceIdMap));
  } catch {}
}
function saveDeviceIdMap() {
  try { fs.writeFileSync(DEVICE_ID_MAP_PATH, JSON.stringify(Object.fromEntries(deviceIdMap), null, 2), 'utf8'); } catch {}
}
loadDeviceIdMap();

// Guard against concurrent connect attempts for the same serial path
const connectingPaths = new Set(); // Set<string>

// Legacy single device variables (for backward compatibility)
let serial = null;
let serialPath = null;
let serialBuf = '';
let deviceVersion = null;

const app = express();
const server = http.createServer(app);
const wss = new WebSocket.Server({ server });

// OSC UDP Port for broadcasting to Ableton M4L (lazy init)
let udpPort = null;

function initOSC() {
    if (!udpPort) {
        try {
            udpPort = new osc.UDPPort({
                localAddress: "0.0.0.0",
                localPort: 9001,
                broadcast: true,
                metadata: true
            });
            
            udpPort.on("ready", () => {
                console.log(`üì° OSC Sender: Ready on port 9001 (Bridge ‚Üí M4L ${M4L_IP}:${M4L_PORT})`);
            });
            
            udpPort.on("error", (err) => {
                console.error("‚ùå OSC Sender error:", err.message);
            });
            
            udpPort.open();
        } catch (err) {
            console.error("‚ùå OSC init error:", err.message);
        }
    }
    return udpPort;
}

// Track device IP for WiFi mode (for display/status only)
let deviceIP = "127.0.0.1"; // Default to localhost for wired mode

// M4L always runs on localhost
const M4L_IP = "127.0.0.1";
const M4L_PORT = 8001;  // Changed from 9000 to avoid conflicts

// Ableton connection tracking (module scope for API access)
let abletonConnected = false;
let trackAcceptUntil = 0; // Only accept track updates during this window
let refreshRouting = { active: false, order: [], count: 0, max: 0 }; // Deterministic routing during Refresh
let refreshTrackSeen = new Set(); // per-refresh dedupe of /trackname by globalTrack
let abletonGreetingSent = false; // Flag to ensure one-time message
let lastHiTime = 0;
let lastHelloResponse = 0;

// Send OSC message to Ableton (M4L)
function sendOSC(address, args = []) {
    const port = initOSC();
    if (!port) {
        console.error('‚ùå OSC port not initialized - cannot send', address);
        return;
    }
    
    if (!port.socket || !port.socket._handle) {
        console.error('‚ùå OSC socket not ready - cannot send', address);
        return;
    }
    
    try {
        // Send to M4L (always localhost)
        port.send({
            address: address,
            args: args
        }, M4L_IP, M4L_PORT);
        const argsStr = args.length > 0 ? ' [' + args.map(a => a.value || a).join(', ') + ']' : '';
        console.log(`üì§ OSC ‚Üí M4L (${M4L_IP}:${M4L_PORT}): ${address}${argsStr}`);
        
        // Broadcast to browser UI
        wsBroadcast({ 
            type: 'osc-sent', 
            address: address, 
            args: args,
            argsStr: argsStr
        });
    } catch (err) {
        console.error(`‚ùå OSC send error (${address}):`, err.message, err.stack);
    }
}

// OSC Listener on port 8000 for receiving commands from M4L
let oscListener = null;
let oscListenerAlt = null;

function initOSCListener() {
    if (!oscListener) {
        try {
            oscListener = new osc.UDPPort({
                localAddress: "0.0.0.0",
                localPort: OSC_LISTEN_PORT,
                metadata: true
            });
            
            // Simple handshake: send /hello, expect /hi back
            // (variables are in module scope)
            
            // Function to check connection and send hello (idle-preferred; force if stale)
            const checkConnection = () => {
                const now = Date.now();
                const msSinceLastHi = lastHiTime ? (now - lastHiTime) : Number.MAX_SAFE_INTEGER;
                if (isProcessingQueue && msSinceLastHi < 25000) {
                    console.log('‚è∏Ô∏è Busy sending track names, recent /hi seen - skipping /hello');
                    return;
                }
                // Send /hello (either idle or stale)
                const timeSinceLastHi = lastHiTime ? Math.floor(msSinceLastHi / 1000) : null;
                console.log(`>>> Handshake check... (last /hi: ${timeSinceLastHi ? timeSinceLastHi + 's ago' : 'never'})`);
                sendOSC('/hello', []);
                
                // Check if we got /hi in last 30 seconds
                if (lastHiTime && (now - lastHiTime < 30000)) {
                    if (!abletonGreetingSent) {
                        console.log('‚úÖ Ableton connection confirmed via /hi handshake');
                        // Send a one-time alert to all connected devices
                        sendToAll(`ALERT "Ableton Connected!" 1000\n`);
                        abletonGreetingSent = true; // Set flag to prevent re-sending
                    }
                    abletonConnected = true;
                    wsBroadcast({ type: 'ableton-connected' });
                } else {
                    if (abletonConnected) {
                        abletonConnected = false;
                        console.log('‚ö†Ô∏è Ableton disconnected (no /hi in 30s)');
                        wsBroadcast({ type: 'ableton-disconnected' });
                    }
                }
            };
            
            // Send first hello immediately after 2 seconds
            setTimeout(() => {
                console.log('üîî Starting Ableton handshake...');
                checkConnection();
            }, 2000);
            
            // Then send /hello every 5 seconds (idle only)
            setInterval(checkConnection, 5000);
            
            // Log raw packets for debugging
            oscListener.on("raw", (data, info) => {
                console.log(`üì¶ RAW OSC packet received from ${info.address}:${info.port}, ${data.length} bytes`);
            });
            
            // Queue for incoming track names to prevent message collision
            const trackNameQueue = [];
            let isProcessingQueue = false;
            const INTRA_DELAY_MS = 80;          // delay between individual /trackname messages (WiFi)
            const INTER_DEVICE_DELAY_MS = 1000; // delay between device batches (WiFi)
            const sleep = (ms) => new Promise(res => setTimeout(res, ms));
            // Deduplicate messages when M4L sends to both ports
            let lastSig = null;
            let lastSigAt = 0;

            // Function to process track name queue in batches
            async function processTrackNameQueue() {
                if (trackNameQueue.length === 0) {
                    isProcessingQueue = false;
                    console.log('‚úÖ Track name queue empty, processing complete');
                    return;
                }

                isProcessingQueue = true;

                // Get the first device ID in the queue
                const nextDeviceId = trackNameQueue[0].deviceId;
                
                // Extract all tracks for this device from the front of the queue
                const itemsForDevice = [];
                while (trackNameQueue.length > 0 && trackNameQueue[0].deviceId === nextDeviceId) {
                    itemsForDevice.push(trackNameQueue.shift());
                }
                
                console.log(`üì¶ [WiFi Queue] Processing ${itemsForDevice.length} tracks for Device ${nextDeviceId} (${trackNameQueue.length} remaining in queue)`);

                // Send all tracks for this device (with intra-message pacing)
                for (const item of itemsForDevice) {
                    const { deviceId, localIndex, name, actualTrack } = item;
                    const cmd = `/trackname ${localIndex} "${name}" ${actualTrack}\n`;
                    try {
                        sendToDevice(deviceId, cmd);
                        console.log(`  ‚Üí Sent track ${actualTrack} (local ${localIndex}) to Device ${deviceId}`);
                    } catch (e) {
                        console.error(`  ‚ùå Error sending track ${actualTrack} to device ${deviceId}:`, e.message);
                    }
                    await sleep(INTRA_DELAY_MS);
                }

                // Wait before processing the next device's batch
                console.log(`‚è±Ô∏è Waiting ${INTER_DEVICE_DELAY_MS}ms before next batch...`);
                setTimeout(processTrackNameQueue, INTER_DEVICE_DELAY_MS);
            }

            const onOscMessage = (oscMsg, timeTag, info, portLabel) => {
                const fromIP = info.address || 'unknown';
                const fromPort = info.port || 'unknown';
                
                // Format args for display
                const argsStr = oscMsg.args && oscMsg.args.length > 0 
                    ? oscMsg.args.map(a => a.value).join(', ') 
                    : '';
                // Build signature and suppress duplicates within 200ms (same addr+args)
                const sig = `${oscMsg.address}|${JSON.stringify(oscMsg.args||[])}`;
                const nowTs = Date.now();
                if (sig === lastSig && (nowTs - lastSigAt) < 1000) {
                    // Duplicate (likely due to dual-port send) ‚Äî ignore
                    return;
                }
                lastSig = sig; lastSigAt = nowTs;

                console.log(`üì® Received OSC (${portLabel}): ${oscMsg.address}${argsStr ? ' [' + argsStr + ']' : ''} from ${fromIP}:${fromPort}`);
                
                wsBroadcast({ type: 'osc-received', from: `${fromIP}:${fromPort}`, address: oscMsg.address, args: oscMsg.args });
                
                // Handle /ipupdate from device (when it connects to WiFi)
                if (oscMsg.address === "/ipupdate") {
                    if (oscMsg.args.length > 0) {
                        const newIP = oscMsg.args[0].value;
                        const ssid = oscMsg.args.length > 1 ? oscMsg.args[1].value : null;
                        
                        console.log(`RECV: /ipupdate ${newIP}`);
                        
                        if (newIP && newIP !== deviceIP) {
                            deviceIP = newIP;
                            
                            wsBroadcast({ 
                                type: 'device-ip', 
                                ip: deviceIP,
                                ssid: ssid,
                                connectionType: newIP === '127.0.0.1' ? 'wired' : 'wifi'
                            });
                            // Transparency log to UI when WiFi IP arrives
                            if (newIP !== '127.0.0.1') {
                              uiLog(`MODE: WIFI`);
                              uiLog(`IP: ${newIP}`);
                              uiLog(`OSC: Bridge listening ${OSC_LISTEN_PORT} (from M4L), sending ${M4L_PORT} (to M4L)`);
                            }
                            
                            // Forward to M4L
                            broadcastIPUpdate();
                        }
                    }
                    return;
                }
                
                // Handle /hi response to our /hello
                if (oscMsg.address === "/hi") {
                    lastHiTime = Date.now();
                    lastHelloResponse = Date.now();
                    const wasConnected = abletonConnected;
                    abletonConnected = true;
                    
                    console.log(`‚úì Received /hi from M4L (port ${OSC_LISTEN_PORT})`);
                    // Immediately notify UI
                    wsBroadcast({ type: 'ableton-connected' });
                    
                    // Send /ableton_on to all connected devices (multi-device mode) with per-device rate-limit
                    try {
                        const now = Date.now();
                        devices.forEach(device => {
                            if (device.serial && device.serial.isOpen) {
                                const lastAt = lastAbletonOnAt.get(device.id) || 0;
                                if (now - lastAt > 2000) {
                                    sendToDevice(device.id, '/ableton_on\n', 'HANDSHAKE');
                                    lastAbletonOnAt.set(device.id, now);
                                }
                            }
                        });
                    } catch (err) {}
                    
                    if (!wasConnected) {
                        console.log('‚úì Ableton CONNECTED');
                        // Do not auto-request track names; user will click Refresh in UI
                    }
                    return;
                }
                
                // Treat active OSC from M4L as heartbeat too (keeps UI status fresh)
                if (oscMsg.address === "/trackname" || oscMsg.address === "/activetrack") {
                    lastHiTime = Date.now();
                    if (!abletonConnected) {
                        abletonConnected = true;
                        wsBroadcast({ type: 'ableton-connected' });
                    }
                }
                
                // Forward OSC commands to device via serial - gated by Refresh window
                if (oscMsg.address === "/trackname" && oscMsg.args.length >= 2) {
                    const now = Date.now();
                    if (now > trackAcceptUntil) {
                        const windowClosed = trackAcceptUntil === 0 ? 'never opened' : `closed ${Math.floor((now - trackAcceptUntil) / 1000)}s ago`;
                        console.log(`‚õî Ignoring /trackname outside Refresh window (${windowClosed})`);
                        return;
                    }
                    const timeLeft = Math.floor((trackAcceptUntil - now) / 1000);
                    console.log(`‚úÖ /trackname accepted (window open for ${timeLeft}s more)`);
                    // If no serial connection is open yet, ignore quietly to avoid spam on boot
                    const serialReady = (serial && serial.isOpen) || (devices && devices.length > 0);
                    if (!serialReady) {
                        // Silently ignore to prevent console spam on boot before devices are connected
                        return;
                    }
                    const displayIndex = oscMsg.args[0].value;
                    const nameRaw = oscMsg.args[1].value;
                    let deviceId, localIndex, globalTrack;
                    
                    // Deterministic routing during Refresh: group in 8s per current device order
                    if (refreshRouting.active && refreshRouting.count < refreshRouting.max && refreshRouting.order.length > 0) {
                        const group = Math.floor(refreshRouting.count / 8);
                        deviceId = refreshRouting.order[group];
                        localIndex = refreshRouting.count % 8;
                        globalTrack = deviceId * 8 + localIndex;
                        // Per-refresh dedupe: if we've already processed this globalTrack, skip
                        const key = `gt:${globalTrack}`;
                        if (refreshTrackSeen.has(key)) {
                            console.log(`‚è≠Ô∏è  Skipping duplicate /trackname for global track ${globalTrack} during refresh`);
                            return;
                        }
                        refreshTrackSeen.add(key);
                        refreshRouting.count++;
                        if (refreshRouting.count >= refreshRouting.max) refreshRouting.active = false;
                    } else {
                        // Fallback: derive from actualTrack argument if provided
                        let actualTrack = oscMsg.args.length >= 3 ? oscMsg.args[2].value : displayIndex;
                        if (typeof actualTrack === 'number' && actualTrack >= 1 && actualTrack <= 32) {
                            actualTrack = actualTrack - 1;
                        }
                        deviceId = Math.floor(actualTrack / 8);
                        localIndex = actualTrack % 8;
                        globalTrack = deviceId * 8 + localIndex;
                        // Best-effort dedupe outside formal refresh window within short time
                        const key = `gt:${globalTrack}`;
                        if ((Date.now() - lastSigAt) < 500 && refreshTrackSeen.has(key)) {
                            console.log(`‚è≠Ô∏è  Skipping near-duplicate /trackname for global track ${globalTrack}`);
                            return;
                        }
                    }

                    const esc = String(nameRaw).replace(/"/g, '\\"');
                    const targetDevice = devices.find(d => d.id === deviceId);
                    
                    console.log(`üîç Track routing: Track ${globalTrack} ‚Üí Device ${deviceId} (local index ${localIndex})`);
                    if (targetDevice) {
                        console.log(`  ‚Üí Target device found: ID=${targetDevice.id}, Mode=${targetDevice.connectionMode}, IP=${targetDevice.ip}`);
                        
                        // Build command and enqueue with pacing (applies to both wired and WiFi)
                        const cmd = `/trackname ${localIndex} \"${esc}\" ${globalTrack}\n`;
                        const key = `${deviceId}:${globalTrack}`;
                        const prev = trackSendMap.get(key);
                        if (prev && prev.name === String(nameRaw) && (Date.now() - prev.at) < 500) {
                            console.log(`‚è≠Ô∏è  track-dedupe (OSC) for device ${deviceId}, track ${globalTrack}, name "${String(nameRaw)}"`);
                            return;
                        }
                        enqueueSendToDevice(deviceId, cmd, 'OSC');
                        trackSendMap.set(key, { name: String(nameRaw), at: Date.now() });
                    } else {
                        // Device not connected - silently skip this track
                        console.log(`‚ö†Ô∏è Device ${deviceId} not connected - skipping track ${globalTrack}`);
                    }

                    // Store the UNESCAPED name for UI/API (not the escaped version)
                    if (displayIndex >= 0 && displayIndex < 32) {
                        currentTrackNames[displayIndex] = String(nameRaw);
                    }
                    return;
                }
                else if (oscMsg.address === "/activetrack" && oscMsg.args.length >= 1) {
                    const idx = oscMsg.args[0].value;
                    wsBroadcast({ type: 'active-track', index: idx });
                }
                else if (oscMsg.address === "/ping") {
                    send(`/ping\n`);
                }
            };

            oscListener.on("message", (m, t, info) => onOscMessage(m, t, info, `:${OSC_LISTEN_PORT}`));
            
            oscListener.on("error", (err) => {
                console.error("OSC listener error:", err.message);
            });
            
            oscListener.on("ready", () => {
                console.log(`üéß OSC Listener: Ready on port ${OSC_LISTEN_PORT} (receives from Ableton)`);
            });
            
            oscListener.open();

            // Optional: enable alternate listener on 8000 for debugging/WiFi sniffing
            const enableAlt = String(process.env.ENABLE_OSC_ALT || '').trim();
            if (enableAlt && !oscListenerAlt) {
                try {
                    oscListenerAlt = new osc.UDPPort({
                        localAddress: '0.0.0.0',
                        localPort: OSC_LISTEN_PORT_ALT,
                        metadata: true
                    });
                    oscListenerAlt.on('message', (m, t, info) => onOscMessage(m, t, info, `:${OSC_LISTEN_PORT_ALT}`));
                    oscListenerAlt.on('ready', () => console.log(`üéß OSC Alt-Listener: Ready on port ${OSC_LISTEN_PORT_ALT}`));
                    oscListenerAlt.on('error', (e) => console.error('OSC alt listener error:', e.message));
                    oscListenerAlt.open();
                } catch (e) {
                    console.error('OSC alt listener init error:', e.message);
                }
            } else {
                console.log(`‚ÑπÔ∏è OSC Alt-Listener on port ${OSC_LISTEN_PORT_ALT} disabled (wired mode - use port ${OSC_LISTEN_PORT} only)`);
            }

            // Port 8000 listener disabled for wired mode to prevent duplicate messages
            // Only port 8003 is used for M4L communication in wired mode
            // Port 8000 is reserved for WiFi device communication
            console.log(`‚ÑπÔ∏è OSC Alt-Listener on port ${OSC_LISTEN_PORT_ALT} disabled (wired mode - use port ${OSC_LISTEN_PORT} only)`);
        } catch (err) {
            console.error("OSC listener init error:", err.message);
        }
    }
    return oscListener;
}

// OSC Listener on port 9000 for receiving /ipupdate from TDS-8 device
let deviceListener = null;

function initDeviceListener() {
    if (!deviceListener) {
        try {
            deviceListener = new osc.UDPPort({
                localAddress: "0.0.0.0",
                localPort: 9000,
                metadata: true
            });
            
            deviceListener.on("message", (oscMsg) => {
                // Only handle /ipupdate from device
                if (oscMsg.address === "/ipupdate" && oscMsg.args.length > 0) {
                    const newIP = oscMsg.args[0].value;
                    // New: deviceID provided as second arg (int). If not present, remains null
                    let reportedDeviceId = null;
                    if (oscMsg.args.length > 1) {
                        const v = oscMsg.args[1].value;
                        if (typeof v === 'number' && Number.isInteger(v)) reportedDeviceId = v;
                    }
                    const ssid = oscMsg.args.length > 2 ? oscMsg.args[2].value : null;
                    
                    console.log(`RECV: /ipupdate ${newIP} (from device)`);
                    
                    if (newIP) {
                        const changed = newIP !== deviceIP;
                        deviceIP = newIP;
                        
                        const connectionType = newIP === '127.0.0.1' ? 'wired' : 'wifi';
                        console.log(`üì° Broadcasting device-ip to UI: ${connectionType} @ ${deviceIP}`);
                        
                        // Update device to WiFi mode with this IP.
                        // Prefer explicit reportedDeviceId. Fallback: first device still on 127.0.0.1, sorted by id.
                        if (connectionType === 'wifi') {
                            let updated = false;
                            // Avoid duplicate assignment
                            const alreadyAssigned = devices.find(d => d.ip === newIP);
                            if (alreadyAssigned) {
                                console.log(`‚ö†Ô∏è IP ${newIP} already assigned to Device ${alreadyAssigned.id}, skipping`);
                            } else if (reportedDeviceId !== null) {
                                // Match by the device's reported firmware ID (device.deviceID), not our UI mapping id
                                const target = devices.find(d => d.deviceID === reportedDeviceId);
                                if (target) {
                                    target.connectionMode = 'wifi';
                                    target.ip = newIP;
                                    console.log(`üì± Updated Device ${target.id} (${target.path}) to WiFi mode via reported ID: ${newIP}`);
                                    updated = true;
                                } else {
                                    console.log(`‚ö†Ô∏è /ipupdate reported deviceId=${reportedDeviceId} but no such device is connected.`);
                                }
                            }
                            if (!updated) {
                                // Fallback behavior only if no wired serial is currently open
                                const anyWiredOpen = devices.some(dev => dev.serial && dev.serial.isOpen);
                                if (!anyWiredOpen) {
                                    const sortedDevices = [...devices].sort((a, b) => a.id - b.id);
                                    for (const d of sortedDevices) {
                                        if (d.ip === '127.0.0.1' && !(d.serial && d.serial.isOpen)) {
                                            d.connectionMode = 'wifi';
                                            d.ip = newIP;
                                            console.log(`üì± Updated Device ${d.id} (${d.path}) to WiFi mode: ${newIP}`);
                                            updated = true;
                                            break;
                                        }
                                    }
                                    if (!updated) {
                                        console.log(`‚ö†Ô∏è Received /ipupdate for ${newIP} but no eligible devices for WiFi assignment`);
                                    }
                                } else {
                                    console.log('‚ö†Ô∏è Ignoring WiFi fallback: wired serial connections are active');
                                }
                            }
                        }
                        
                        // Always broadcast to UI (even if IP didn't change, UI might need update)
                        wsBroadcast({ 
                            type: 'device-ip', 
                            ip: deviceIP,
                            ssid: ssid,
                            connectionType: connectionType,
                            devices: devices.map(d => ({ id: d.id, path: d.path, mode: d.connectionMode, ip: d.ip }))
                        });
                        
                        // Log WiFi mode port configuration
                        if (connectionType === 'wifi') {
                            uiLog(`üì° WiFi Mode Active - Device IP: ${deviceIP}`);
                        }
                        
                        // Do not auto-request track names on IP change; user triggers Refresh
                    }
                }
            });
            
            deviceListener.on("ready", () => {
                console.log(`üì° Device Listener: Ready on port 9000 (receives /ipupdate from TDS-8)`);
            });
            
            deviceListener.on("error", (err) => {
                console.error("Device listener error:", err.message);
            });
            
            deviceListener.open();
        } catch (err) {
            console.error("Device listener init error:", err.message);
        }
    }
    return deviceListener;
}

// Start OSC sender and listener immediately
console.log('\n========== OSC INITIALIZATION ==========');
console.log('Calling initOSC()...');
const oscSender = initOSC();        // Initialize OSC sender
console.log('OSC Sender returned:', oscSender ? 'object' : 'null');

console.log('Calling initOSCListener()...');
const oscReceiver = initOSCListener(); // Initialize OSC listener (port 8000 - from M4L)
console.log('OSC Listener returned:', oscReceiver ? 'object' : 'null');

console.log('Calling initDeviceListener()...');
initDeviceListener(); // Initialize device listener (port 9000 - from TDS-8)

// Wait a moment for ports to open, then verify
setTimeout(() => {
  console.log('\nüîç OSC Status Check:');
  console.log(`  Sender (port 9001): ${oscSender && oscSender.socket ? '‚úÖ Ready' : '‚ùå Failed'}`);
  console.log(`  Listener (port ${OSC_LISTEN_PORT}): ${oscReceiver && oscReceiver.socket ? '‚úÖ Ready' : '‚ùå Failed'}`);
  
  if (!oscSender || !oscSender.socket) {
    console.error('‚ö†Ô∏è OSC Sender failed to initialize - M4L communication will not work!');
    console.error('   Check if port 9001 is already in use by another application.');
  }
  if (!oscReceiver || !oscReceiver.socket) {
    console.error('‚ö†Ô∏è OSC Listener failed to initialize - Cannot receive from M4L!');
    console.error(`   Check if port ${OSC_LISTEN_PORT} is already in use by another application.`);
  }
  
  // Test send
  console.log('\nüß™ Sending test /hello to M4L...');
  if (oscSender && oscSender.socket) {
    try {
      oscSender.send({ address: '/hello', args: [] }, M4L_IP, M4L_PORT);
      console.log(`‚úÖ Test message sent successfully to ${M4L_IP}:${M4L_PORT}`);
    } catch (e) {
      console.error('‚ùå Test send failed:', e.message);
    }
  }
}, 1000);

console.log('========================================\n');
// Function to broadcast IP update to M4L
function broadcastIPUpdate(overrideIP = null, overrideMode = null) {
    try {
        const port = initOSC();
        if (!port) return;
        const ip = overrideIP || deviceIP || '127.0.0.1';
        const mode = overrideMode || (ip === '127.0.0.1' ? 'wired' : 'wifi');

        // Back-compat: /ipupdate <ip>
        const msgUpdate = { address: "/ipupdate", args: [{ type: "s", value: ip }] };
        console.log(`SENT: /ipupdate ${ip} (to M4L on port ${M4L_PORT})`);
        port.send(msgUpdate, M4L_IP, M4L_PORT);

        // Compatibility: /ipconfig <ip> <mode>
        const msgConfig = { address: "/ipconfig", args: [
            { type: 's', value: ip },
            { type: 's', value: mode }
        ]};
        console.log(`SENT: /ipconfig ${ip} ${mode} (to M4L on port ${M4L_PORT})`);
        port.send(msgConfig, M4L_IP, M4L_PORT);
    } catch (err) {
        console.error("Error:", err.message);
    }
}

app.use(express.json({ limit: '10mb' }));
app.use(morgan('dev'));
app.use(express.static(path.join(__dirname, 'web')));

// Serve index.html at root
app.get('/', (req, res) => {
  res.sendFile(path.join(__dirname, 'web', 'index.html'));
});

// Redirect old favicon.ico requests to favicon.svg
app.get('/favicon.ico', (req, res) => {
  res.redirect(301, '/favicon.svg');
});

function wsBroadcast(obj) {
  const s = JSON.stringify(obj);
  for (const c of wss.clients) if (c.readyState === 1) c.send(s);
}

// Helper: print a line to the Serial Monitor area in the web UI
function uiLog(line) {
  try { wsBroadcast({ type: 'serial-data', data: line }); } catch {}
}

// Helper: dedupe rapid duplicate sends to a device (same exact command within 1000ms)
function shouldDedupeSend(deviceId, s) {
  try {
    const trimmed = (s || '').trim();
    const now = Date.now();
    const prev = lastSendMap.get(deviceId);
    if (prev && prev.cmd === trimmed && (now - prev.at) < 1000) {
      return true;
    }
    lastSendMap.set(deviceId, { cmd: trimmed, at: now });
    return false;
  } catch { return false; }
}

// -------- Serial helpers --------
async function listPorts() {
  try { return await Bindings.list(); }
  catch { return []; }
}

async function openSerial(desiredPath) {
  if (serial && serial.isOpen && desiredPath && desiredPath !== serialPath) {
    try { serial.close(); } catch {}
    serial = null; serialPath = null;
  }
  if (serial && serial.isOpen) return serial.path;
  if (!desiredPath) throw new Error('No port specified. Select a serial port first.');

  serialPath = desiredPath;
  serial = new SerialPortStream({
    binding: Bindings, path: desiredPath, baudRate: BAUD, autoOpen: false
  });
  await new Promise((res, rej) => serial.open(err => err ? rej(err) : res()));

  // Legacy handler removed - multi-device mode uses onSerialDataMulti instead
  // serial.on('data', onSerialData);
  serial.on('error', e => wsBroadcast({ type: 'serial-error', message: e.message }));
  serial.on('close', () => wsBroadcast({ type: 'serial-close', path: serialPath }));

  wsBroadcast({ type: 'serial-open', path: serialPath, baud: BAUD });
  console.log(`Serial Port: ${serialPath} @ ${BAUD} baud`);
  // Removed premature /reannounce here to avoid early track pushes before DEVICE_IDs set
  send('VERSION\n');
  return serialPath;
}

function send(s) {
  if (!serial || !serial.isOpen) {
    console.error('‚ùå Cannot send - Serial not open');
    throw new Error('Serial not open');
  }
  serial.write(s);
  console.log(`SENT: ${s.trim()}`);
  uiLog(`[SERIAL] SENT: ${s.trim()}`);
}

// Multi-device: Send to specific device by ID
// Queueing wrapper with global pacing
function sendToDevice(deviceId, s, origin = 'unknown') {
  console.log(`üóÇÔ∏è  [queue origin=${origin}] deviceId=${deviceId} cmd=${String(s || '').trim()}`);
  enqueueSendToDevice(deviceId, s, origin);
}

// Immediate send (internal): performs actual serial/OSC write
function sendToDeviceImmediate(deviceId, s, origin = 'unknown') {
  console.log(`üîç [sendToDevice origin=${origin}] Attempting to send to deviceId=${deviceId}`);
  console.log(`üîç [sendToDevice] Current devices array:`, devices.map(d => `[id=${d.id}, path=${d.path}, mode=${d.connectionMode}, ip=${d.ip}]`).join(', '));
  
  const device = devices.find(d => d.id === deviceId);
  if (!device) {
    console.error(`‚ùå Device with id=${deviceId} not found in devices array`);
    throw new Error(`Device ${deviceId} not found`);
  }
  // Short per-device send lock to guard against racing callers ‚Äî but do NOT
  // lock for rapid /trackname or /activetrack batches (Update All Tracks flow)
  const trimmed = String(s || '').trim();
  const addr = trimmed.split(' ')[0] || '';
  if (addr !== '/trackname' && addr !== '/activetrack') {
    const nowLock = Date.now();
    if (device.__sendLockUntil && nowLock < device.__sendLockUntil) {
      console.log(`‚è≥ Send locked for Device ${deviceId} ‚Äî dropping: ${trimmed}`);
      return;
    }
    device.__sendLockUntil = nowLock + 150;
  }
  
  // Check if device is in WiFi mode
  if (device.connectionMode === 'wifi' && device.ip && device.ip !== '127.0.0.1') {
    if (shouldDedupeSend(deviceId, s)) {
      console.log(`‚è≠Ô∏è  Skipping duplicate WiFi send to Device ${deviceId} (origin=${origin}): ${s.trim()}`);
      return;
    }
    // Send via OSC to device's WiFi IP
    const port = initOSC();
    if (!port) {
      console.error(`‚ùå OSC port not initialized - cannot send to WiFi device`);
      throw new Error('OSC not initialized');
    }

    // Parse the command string into properly typed OSC args
    const trimmed = s.trim();
    const address = trimmed.split(' ')[0];
    let args = [];

    if (address === '/trackname') {
      // Expect: /trackname <idx> "<name>" <actualTrack>
      const m = trimmed.match(/^\/trackname\s+(\d+)\s+"([\s\S]*?)"\s+(\d+)$/);
      if (m) {
        const idx = parseInt(m[1], 10);
        const name = m[2].replace(/\\\"/g, '"');
        const at = parseInt(m[3], 10);
        args = [
          { type: 'i', value: idx },
          { type: 's', value: name },
          { type: 'i', value: at }
        ];
      } else {
        console.warn('‚ö†Ô∏è Unexpected /trackname format, falling back to naive split:', trimmed);
        const parts = trimmed.split(' ').slice(1);
        // Best-effort: first and last as ints, middle joined as string
        const first = parseInt(parts[0], 10);
        const last = parseInt(parts[parts.length - 1], 10);
        const middle = parts.slice(1, -1).join(' ').replace(/^"|"$/g, '');
        args = [
          { type: 'i', value: isNaN(first) ? 0 : first },
          { type: 's', value: middle },
          { type: 'i', value: isNaN(last) ? first : last }
        ];
      }
    } else if (address === '/activetrack') {
      const m = trimmed.match(/^\/activetrack\s+(\d+)$/);
      if (m) args = [{ type: 'i', value: parseInt(m[1], 10) }];
    } else if (address === '/reannounce') {
      args = [];
    } else {
      // Generic fallback: try to type ints, else strings
      const parts = trimmed.split(' ').slice(1);
      args = parts.map(p => (/^-?\d+$/.test(p) ? { type: 'i', value: parseInt(p, 10) } : { type: 's', value: p }));
    }

    try {
      port.send({ address, args }, device.ip, 8000);
      console.log(`üì° SENT via OSC to Device ${deviceId} (${device.ip}:8000) [origin=${origin}]: ${trimmed}`);
      uiLog(`[Device ${deviceId}] OSC ‚Üí ${device.ip}:8000 [${origin}]: ${trimmed}`);
    } catch (err) {
      console.error(`‚ùå OSC send error to ${device.ip}:`, err.message);
      throw err;
    }
  } else {
    // Send via Serial (wired mode)
    if (!device.serial) {
      console.error(`‚ùå Device ${deviceId} has no serial object`);
      throw new Error(`Device ${deviceId} has no serial connection`);
    }
    if (!device.serial.isOpen) {
      console.error(`‚ùå Device ${deviceId} serial port is not open`);
      throw new Error(`Device ${deviceId} serial port closed`);
    }
    
    if (shouldDedupeSend(deviceId, s)) {
      console.log(`‚è≠Ô∏è  Skipping duplicate Serial send to Device ${deviceId} (origin=${origin}): ${s.trim()}`);
      return;
    }
    device.serial.write(s);
    console.log(`‚úÖ SENT via Serial to Device ${deviceId} (${device.path}) [origin=${origin}]: ${s.trim()}`);
    uiLog(`[Device ${deviceId}] SERIAL [${origin}]: ${s.trim()}`);
  }
}

// Multi-device: Send to all connected devices
function sendToAll(s, origin = 'BROADCAST') {
  devices.forEach(device => {
    try { sendToDevice(device.id, s, origin); } catch (e) { console.warn(`sendToAll error for device ${device.id}:`, e.message); }
  });
}

// Multi-device: Handle serial data from specific device
function onSerialDataMulti(device, chunk) {
  try {
  const text = chunk.toString('utf8');
  device.buffer += text;
  // Do NOT broadcast raw chunks - only broadcast parsed lines below to avoid duplicates
  let idx;
  while ((idx = device.buffer.indexOf('\n')) >= 0) {
    const line = device.buffer.slice(0, idx).trim();
    device.buffer = device.buffer.slice(idx + 1);
    if (line) {
      console.log(`RECV from Device ${device.id}: ${line}`);
      wsBroadcast({ type: 'serial-data', deviceId: device.id, data: line });
      
      // Parse DEVICE_ID response
      const deviceIdMatch = /^DEVICE_ID\s*[:=]\s*(\d+)/i.exec(line);
      if (deviceIdMatch) {
        device.deviceID = parseInt(deviceIdMatch[1]);
        console.log(`‚úì Device ${device.id} confirmed DEVICE_ID: ${device.deviceID}`);
      }
      
      // Parse VERSION response
      const versionMatch = /^VERSION\s*[:=]\s*(.+)/i.exec(line);
      if (versionMatch) {
        device.version = versionMatch[1];
        console.log(`‚úì Device ${device.id} version: ${device.version}`);
        wsBroadcast({ type: 'device-version', version: device.version, path: device.path, deviceId: device.id });
      }
    }
  }
} catch (e) {
  console.error(`CRITICAL: onSerialDataMulti error for device ${device.id}:`, e);
  uiLog(`FATAL: Serial data handler failed for device ${device.id}: ${e.message}`);
}
}

function onSerialData(chunk) {
  const text = chunk.toString('utf8');
  serialBuf += text;
  let idx;
  while ((idx = serialBuf.indexOf('\n')) >= 0) {
    const line = serialBuf.slice(0, idx).trim();
    serialBuf = serialBuf.slice(idx + 1);
    const trimmedLine = line.trim();
    if (trimmedLine) {
      // Only broadcast clean lines, not raw buffer data
      wsBroadcast({ type: 'serial-data', data: `Received: ${trimmedLine}` });
      console.log(`RECV: ${trimmedLine}`);
    }
    const m = /^VERSION\s*[:=]\s*([\w.\-]+)/i.exec(line);
    if (m) { deviceVersion = m[1]; wsBroadcast({ type: 'device-version', version: deviceVersion }); }
    
    // Parse MODE: WIRED or MODE: WIFI
    const modeMatch = /^MODE\s*[:=]\s*(WIRED|WIFI)/i.exec(line);
    if (modeMatch) {
      const mode = modeMatch[1].toUpperCase();
      const connectionType = mode === 'WIRED' ? 'wired' : 'wifi';
      if (mode === 'WIRED') {
        deviceIP = '127.0.0.1';
      }
      // For WiFi mode, keep existing deviceIP or wait for /ipupdate
      wsBroadcast({ 
        type: 'device-mode', 
        mode: connectionType,
        ip: mode === 'WIRED' ? '127.0.0.1' : (deviceIP || 'Connecting...')
      });
      // Transparency log to UI when mode line seen over serial
      uiLog(`MODE: ${mode}`);
      const ipNow = mode === 'WIRED' ? '127.0.0.1' : (deviceIP || 'pending‚Ä¶');
      uiLog(`IP: ${ipNow}`);
      uiLog(`OSC: Bridge listening ${OSC_LISTEN_PORT} (from M4L), sending ${M4L_PORT} (to M4L)`);
    }
  }
}

// -------- API --------
app.get('/api/ports', async (_req, res) => {
  const ports = await listPorts();

  // Helper: filter out Bluetooth virtual serial ports
  const isBluetoothPort = (p) => {
    const pnp = (p.pnpId || '').toUpperCase();
    const manu = (p.manufacturer || '').toLowerCase();
    const name = (p.friendlyName || '').toLowerCase();
    return pnp.includes('BTHENUM') || manu.includes('bluetooth') || name.includes('bluetooth');
  };

  // Filter for TDS-8 devices (XIAO ESP32-C3 preferred)
  const tds8Devices = ports.filter(p => {
    const vid = (p.vendorId || '').toUpperCase();
    const pid = (p.productId || '').toUpperCase();
    const manu = (p.manufacturer || '').toLowerCase();
    // Match specific VID/PID for ESP32-C3, or common Arduino names, and exclude Bluetooth
    const isTds = (vid === '303A' && pid === '1001') || manu.includes('arduino') || manu.includes('tds-8');
    return isTds && !isBluetoothPort(p);
  });

  let list = tds8Devices;
  if (list.length === 0) {
    // Fallback: return non-Bluetooth ports so user can choose manually
    console.log('‚ö†Ô∏è No VID/PID match; falling back to non-Bluetooth serial ports');
    list = ports.filter(p => !isBluetoothPort(p));
    // On Windows, if still empty, try PowerShell discovery of COM ports
    if (list.length === 0 && process.platform === 'win32') {
      try {
        await new Promise((resolve) => {
          const cmd = 'powershell -NoProfile -Command "try { Get-CimInstance Win32_SerialPort | Select-Object -ExpandProperty DeviceID } catch { try { Get-WmiObject Win32_SerialPort | Select-Object -ExpandProperty DeviceID } catch {} }"';
          exec(cmd, { windowsHide: true }, (err, stdout) => {
            if (!err && stdout) {
              const lines = stdout.split(/\r?\n/).map(s => s.trim()).filter(Boolean);
              const extra = lines.filter(s => /^COM\d+$/i.test(s)).map(id => ({ path: id }));
              if (extra.length > 0) {
                console.log('‚ûï Discovered COM ports via PowerShell:', extra.map(e => e.path));
                list = extra;
              }
            }
            resolve();
          });
        });
      } catch (e) {
        console.log('PowerShell COM discovery skipped:', e.message);
      }
    }
  } else {
    console.log(`‚úì Filtered devices (VID=303A, PID=1001): ${tds8Devices.length} found`);
  }

  const decorated = list.map(p => ({
    path: p.path,
    label: [p.manufacturer, p.path].filter(Boolean).join(' - ') || p.path,
    vendorId: p.vendorId || '',
    productId: p.productId || '',
    serialNumber: p.serialNumber || '',
    manufacturer: p.manufacturer || '',
    pnpId: p.pnpId || '',
    isTDS8: tds8Devices.some(t => t.path === p.path)
  }));
  res.json(decorated);
});

// New endpoint to get ALL serial ports (unfiltered) for alternate connection dropdown
app.get('/api/ports/all', async (_req, res) => {
  const ports = await listPorts();
  const psPortInfo = new Map(); // Store PowerShell data by DeviceID
  
  // On Windows, get detailed port info from PowerShell
  if (process.platform === 'win32') {
    try {
      const discoveredPorts = await new Promise((resolve) => {
        const cmd = 'powershell -NoProfile -Command "Get-WmiObject Win32_SerialPort | Select-Object DeviceID, Name, Description | ConvertTo-Json"';
        exec(cmd, { windowsHide: true, timeout: 5000 }, (err, stdout) => {
          if (err || !stdout) {
            console.log('PowerShell command failed or returned no output. Using basic list.');
            return resolve([]); // Resolve with empty array on error
          }
          try {
            const psData = JSON.parse(stdout.trim());
            const psArray = Array.isArray(psData) ? psData : [psData];
            resolve(psArray.filter(p => p.DeviceID)); // Filter out invalid entries
          } catch (e) {
            console.log('PowerShell JSON parse error:', e.message);
            resolve([]); // Resolve with empty array on parse error
          }
        });
      });

      // Add discovered ports to the main list if they aren't already there
      discoveredPorts.forEach(psPort => {
        psPortInfo.set(psPort.DeviceID, { name: psPort.Name, description: psPort.Description });
        if (!ports.some(p => p.path === psPort.DeviceID)) {
          ports.push({
            path: psPort.DeviceID,
            manufacturer: psPort.Name || psPort.Description || '',
            pnpId: psPort.Description || ''
          });
        }
      });

    } catch (e) {
      console.log('PowerShell COM discovery completely failed:', e.message);
    }
  }
  
  const decorated = ports.map(p => {
    let displayLabel = p.path;
    
    // Prefer PowerShell Name over manufacturer
    const psInfo = psPortInfo.get(p.path);
    if (psInfo && psInfo.name) {
      displayLabel = psInfo.name;
      console.log(`‚úì Using PowerShell name for ${p.path}: ${displayLabel}`);
    } else if (p.manufacturer && p.manufacturer !== 'Microsoft') {
      displayLabel = `${p.manufacturer} - ${p.path}`;
      console.log(`Using manufacturer for ${p.path}: ${displayLabel}`);
    } else {
      console.log(`‚ö†Ô∏è No good label for ${p.path}, using path only. Manufacturer: ${p.manufacturer}`);
    }
    
    return {
      path: p.path,
      label: displayLabel,
      vendorId: p.vendorId || '',
      productId: p.productId || '',
      serialNumber: p.serialNumber || '',
      manufacturer: p.manufacturer || '',
      pnpId: p.pnpId || ''
    };
  });
  
  const filteredPorts = decorated.filter(p => {
    const mfg = (p.manufacturer || '').toLowerCase();
    const lbl = (p.label || '').toLowerCase();
    const isTDS8 = 
      mfg.includes('arduino') || 
      mfg.includes('seeed') || 
      lbl.includes('tds-8') || 
      p.vendorId === '2886' || // Seeed Studio
      p.vendorId === '2341' || // Arduino
      p.vendorId === '1a86';   // Common CH340 serial chip

    if (isTDS8) console.log(`‚úì Found potential TDS-8: ${p.label}`);
    return isTDS8;
  });

  console.log(`‚úÖ Filtered to ${filteredPorts.length} potential TDS-8 device(s)`);
  res.json(filteredPorts);
});

// Map COM ports to device IDs (persistent across disconnects)
const portToDeviceId = new Map();

app.post('/api/connect', async (req, res) => {
  try {
    const desired = req.body && req.body.path;
    const requestedDeviceId = req.body && req.body.deviceId; // Frontend can specify device ID
    if (!desired) throw new Error('Missing path');
    
    // Check if device is already connected
    const existingDevice = devices.find(d => d.path === desired);
    if (existingDevice) {
      console.log(`‚ö†Ô∏è Device ${desired} already connected as Device ID ${existingDevice.deviceID}`);
      return res.json({ ok: true, path: desired, baud: BAUD, deviceId: existingDevice.deviceID, alreadyConnected: true });
    }

    // Prevent concurrent connects for the same port
    if (connectingPaths.has(desired)) {
      console.log(`‚è≥ Connect already in-flight for ${desired} ‚Äî ignoring duplicate request`);
      return res.json({ ok: false, path: desired, error: 'Connect in progress' });
    }
    connectingPaths.add(desired);
    
    // Determine device ID: use requested ID, or check port mapping, or assign next available
    let deviceId;
    if (requestedDeviceId !== undefined) {
      deviceId = requestedDeviceId;
      portToDeviceId.set(desired, deviceId);
    } else if (portToDeviceId.has(desired)) {
      // This port has been used before - restore its ID
      deviceId = portToDeviceId.get(desired);
      console.log(`üìå Restoring Device ID ${deviceId} for ${desired} (previously assigned)`);
    } else {
      // New port - assign next available ID (0-3)
      const usedIds = new Set(Array.from(portToDeviceId.values()));
      for (let i = 0; i < MAX_DEVICES; i++) {
        if (!usedIds.has(i)) {
          deviceId = i;
          break;
        }
      }
      if (deviceId === undefined) deviceId = 0; // Fallback
      portToDeviceId.set(desired, deviceId);
      console.log(`üÜï Assigning Device ID ${deviceId} to ${desired} (new port)`);
    }
    
    // Use consistent multi-device pattern for all devices (including first)
    const newSerial = new SerialPortStream({ binding: Bindings, path: desired, baudRate: BAUD });
    
    const device = {
      id: deviceId,
      serial: newSerial,
      path: desired,
      buffer: '',
      version: null,
      deviceID: deviceId,
      connectionMode: 'wired',  // 'wired' or 'wifi'
      ip: '127.0.0.1'           // Current IP address
    };
    
    devices.push(device);
    
    console.log(`üìä [DEVICES] Array after connection:`, devices.map(d => `[ID=${d.deviceID}, path=${d.path}]`).join(', '));
    
    // Set up data handler for this device (guard against duplicate attach)
    try { newSerial.removeAllListeners && newSerial.removeAllListeners('data'); } catch {}
    if (!newSerial.__tds8DataAttached) {
      newSerial.on('data', (chunk) => onSerialDataMulti(device, chunk));
      newSerial.__tds8DataAttached = true;
    }
    newSerial.on('error', e => {
      console.error(`‚ùå Device ${deviceId} error:`, e.message);
      wsBroadcast({ type: 'serial-error', deviceId, message: e.message });
    });
    newSerial.on('close', () => {
      console.log(`üîå Device ${deviceId} disconnected: ${desired}`);
      wsBroadcast({ type: 'serial-close', deviceId, path: desired });
      // Remove from devices array
      const index = devices.findIndex(d => d.id === deviceId);
      if (index !== -1) devices.splice(index, 1);
    });
    
    // For first device, also set legacy global variables for backward compatibility
    // NOTE: Do NOT attach legacy 'onSerialData' handler - multi-device handler already attached
    if (devices.length === 1) {
      serial = newSerial;
      serialPath = desired;
      serialBuf = device.buffer;
      deviceIP = '127.0.0.1';
      
      // Broadcast IP update to M4L
      setTimeout(() => broadcastIPUpdate(), 500);
    }
    
    // Send DEVICE_ID command to set track offset
    setTimeout(() => {
      sendToDevice(deviceId, `DEVICE_ID ${deviceId}\n`);
      sendToDevice(deviceId, 'VERSION\n');
      console.log(`‚úì Connected: ${desired} ‚Üí Device ID ${deviceId} (Tracks ${deviceId * 8 + 1}-${(deviceId + 1) * 8})`);

    }, 1000);
    
    // Broadcast device status to UI (wired mode)
    deviceIP = '127.0.0.1';
    wsBroadcast({
      type: 'device-mode',
      mode: 'wired',
      ip: '127.0.0.1'
    });
    // Inform M4L explicitly that we are in wired mode (localhost)
    setTimeout(() => broadcastIPUpdate('127.0.0.1', 'wired'), 300);
    
    wsBroadcast({ type: 'serial-open', path: desired, baud: BAUD });
    res.json({ ok: true, path: desired, baud: BAUD, deviceId });
  } catch (e) {
    console.error('CRITICAL: /api/connect error:', e);
    uiLog(`FATAL: Connection handler failed: ${e.message}`);
    res.status(500).json({ ok: false, error: e.message });
  } finally {
    try { if (req && req.body && req.body.path) connectingPaths.delete(req.body.path); } catch {}
  }
});

// Multi-device: Connect multiple TDS-8 devices
app.post('/api/connect-multi', async (req, res) => {
  try {
    const { ports } = req.body; // Array of COM port paths
    if (!ports || !Array.isArray(ports)) throw new Error('Missing ports array');
    
    const results = [];
    for (let i = 0; i < Math.min(ports.length, MAX_DEVICES); i++) {
      const portPath = ports[i];
      try {
        const deviceId = i; // Auto-assign device ID 0-3
        const newSerial = new SerialPortStream({ binding: Bindings, path: portPath, baudRate: BAUD });
        
        const device = {
          id: deviceId,
          serial: newSerial,
          path: portPath,
          buffer: '',
          version: null,
          deviceID: deviceId
        };
        
        devices.push(device);
        
        // Set up data handler for this device (guard against duplicate attach)
        try { newSerial.removeAllListeners && newSerial.removeAllListeners('data'); } catch {}
        if (!newSerial.__tds8DataAttached) {
          newSerial.on('data', (chunk) => onSerialDataMulti(device, chunk));
          newSerial.__tds8DataAttached = true;
        }
        
        // Send DEVICE_ID command to set the device's ID
        setTimeout(() => {
          sendToDevice(deviceId, `DEVICE_ID ${deviceId}\n`);
          sendToDevice(deviceId, 'VERSION\n');
        }, 1000);
        
        results.push({ ok: true, deviceId, path: portPath });
        console.log(`‚úì Device ${deviceId} connected: ${portPath}`);
      } catch (err) {
        results.push({ ok: false, path: portPath, error: err.message });
      }
    }
    
    wsBroadcast({ type: 'multi-device-connected', devices: results });
    res.json({ ok: true, devices: results });
  } catch (e) {
    res.status(500).json({ error: e.message });
  }
});

// User-triggered: ask M4L to re-announce tracks. Does not auto-run elsewhere.
app.post('/api/reannounce', (req, res) => {
  try {
    sendOSC('/reannounce', []);
    // Open a 30s window to accept incoming track updates (extended for reliability)
    trackAcceptUntil = Date.now() + 30000;
    console.log(`‚úÖ Refresh window OPENED: accepting /trackname until ${new Date(trackAcceptUntil).toLocaleTimeString()}`);
    // Capture current order of devices by assigned Device ID for deterministic routing
    const ordered = [...devices].sort((a,b) => a.id - b.id).map(d => d.id);
    refreshRouting = { active: true, order: ordered, count: 0, max: ordered.length * 8 };
    // Reset per-refresh track dedupe set
    try { refreshTrackSeen.clear(); } catch { refreshTrackSeen = new Set(); }
    console.log(`üìã Refresh routing initialized: order=[${ordered.join(',')}], max=${ordered.length * 8} tracks`);
    wsBroadcast({ type: 'log', level: 'info', message: 'üì£ Sent /reannounce to M4L' });
    res.json({ ok: true });
  } catch (e) {
    console.error('Failed to send /reannounce:', e.message);
    res.status(500).json({ ok: false, error: e.message });
  }
});

// Remap a device to a new Device ID. Ensures uniqueness by swapping IDs when needed.
app.post('/api/remap-device-ids', async (req, res) => {
  try {
    const { path, deviceId } = req.body;
    if (typeof path !== 'string' || typeof deviceId !== 'number') {
      return res.status(400).json({ ok: false, error: 'Missing or invalid path/deviceId' });
    }
    if (deviceId < 0 || deviceId >= MAX_DEVICES) {
      return res.status(400).json({ ok: false, error: `deviceId must be 0-${MAX_DEVICES - 1}` });
    }

    const devA = devices.find(d => d.path === path);
    if (!devA) return res.status(404).json({ ok: false, error: 'Device not connected' });

    const oldIdA = devA.id;
    const newIdA = deviceId;
    if (oldIdA === newIdA) {
      return res.json({ ok: true, message: 'No change' });
    }

    // Find any device currently using the target ID
    const devB = devices.find(d => d.id === newIdA);

    // If there is a conflict, swap devB to oldIdA
    if (devB) {
      console.log(`üîÅ Swapping Device IDs: ${devA.path} (${oldIdA}) ‚Üî ${devB.path} (${newIdA})`);
      devB.id = oldIdA;
      devB.deviceID = oldIdA;
      portToDeviceId.set(devB.path, devB.id);
      try {
        sendToDevice(devB.id, `DEVICE_ID ${devB.id}\n`);
        sendToDevice(devB.id, 'VERSION\n');
      } catch (e) {
        console.error(`Failed to update DEVICE_ID on swapped device ${devB.path}:`, e.message);
      }
    }

    // Assign requested ID to devA
    devA.id = newIdA;
    devA.deviceID = newIdA;
    portToDeviceId.set(devA.path, devA.id);
    try {
      sendToDevice(devA.id, `DEVICE_ID ${devA.id}\n`);
      sendToDevice(devA.id, 'VERSION\n');
    } catch (e) {
      console.error(`Failed to update DEVICE_ID on device ${devA.path}:`, e.message);
    }

    // Notify UI and return
    wsBroadcast({ 
      type: 'device-remapped', 
      devices: devices.map(d => ({ id: d.id, path: d.path, mode: d.connectionMode, ip: d.ip }))
    });
    return res.json({ ok: true });
  } catch (e) {
    console.error('CRITICAL: /api/remap-device-ids error:', e);
    res.status(500).json({ ok: false, error: e.message });
  }
});

// Send command to connected device
app.post('/api/send-command', (req, res) => {
  try {
    const { command, deviceId, path } = req.body;
    if (!command) throw new Error('Missing command');
    
    // If deviceId specified, send to that device
    if (deviceId !== undefined && devices.length > 0) {
      console.log(`üîç [ROUTING] Looking for deviceId=${deviceId} in devices:`, devices.map(d => `[ID=${d.deviceID}, id=${d.id}, path=${d.path}]`).join(', '));
      const device = devices.find(d => d.deviceID === deviceId || d.id === deviceId);
      if (device) {
        sendToDevice(device.id, command + '\n');
        console.log(`üì§ [Device ${deviceId}] ${device.path} ‚Üê ${command}`);
      } else {
        console.error(`‚ùå Device ${deviceId} not found in devices array:`, devices.map(d => `ID=${d.deviceID}, path=${d.path}`));
        throw new Error(`Device ${deviceId} not found`);
      }
    } 
    // If path specified, find device by path
    else if (path && devices.length > 0) {
      console.log(`üîç [ROUTING] Looking for path="${path}" in devices:`, devices.map(d => `[ID=${d.deviceID}, path=${d.path}]`).join(', '));
      const device = devices.find(d => d.path === path);
      if (device) {
        sendToDevice(device.id, command + '\n');
        console.log(`üì§ [Device ${device.deviceID}] ${path} ‚Üê ${command}`);
      } else {
        console.error(`‚ùå Device at ${path} not found in devices array:`, devices.map(d => `ID=${d.deviceID}, path=${d.path}`));
        throw new Error(`Device at ${path} not found`);
      }
    }
    // Otherwise send to first device (legacy behavior)
    else {
      send(command + '\n');
      const firstDevice = devices.length > 0 ? devices[0] : null;
      const deviceInfo = firstDevice ? `[Device ${firstDevice.deviceID}] ${firstDevice.path}` : 'first device';
      console.log(`üì§ ${deviceInfo} ‚Üê ${command}`);
    }
    
    res.json({ ok: true });
  } catch (e) {
    res.status(500).json({ error: e.message });
  }
});

app.post('/api/send-command', async (req, res) => {
  try {
    const { command, path } = req.body;
    if (!command) throw new Error('Missing command');
    
    if (path) {
      // Send to specific device
      const device = devices.find(d => d.path === path);
      if (device) {
        sendToDevice(device.id, command + '\n');
        res.json({ ok: true, message: `Command sent to device ${device.id}` });
      } else {
        res.status(404).json({ error: `Device at ${path} not found` });
      }
    } else {
      // Send to all devices
      sendToAll(command + '\n');
      res.json({ ok: true, message: 'Command sent to all devices' });
    }
  } catch (e) {
    console.error('Send command error:', e);
    res.status(500).json({ error: e.message });
  }
});

app.post('/api/disconnect', async (req, res) => {
  try {
    const { path } = req.body;
    
    if (path) {
      // Multi-device: find and disconnect specific device
      const device = devices.find(d => d.path === path);
      if (device) {
        console.log(`üîå Disconnecting multi-device ${device.id}: ${path}`);
        await new Promise((resolve, reject) => {
          device.serial.close(err => {
            if (err) reject(err);
            else resolve();
          });
        });
        // Device will be removed from devices array by the close event handler
        res.json({ ok: true, message: `Device ${device.id + 1} disconnected` });
      } else {
        res.json({ ok: false, message: `Device at ${path} not found` });
      }
    } else if (serial && serial.isOpen) {
      // Legacy single-device disconnect
      await new Promise((resolve, reject) => {
        serial.close(err => {
          if (err) reject(err);
          else resolve();
        });
      });
      serial = null;
      serialPath = null;
      console.log('üîå Serial port closed - Available for Arduino IDE');
      wsBroadcast({ type: 'serial-close', path: null });
      res.json({ ok: true, message: 'Serial port released' });
    } else {
      res.json({ ok: true, message: 'No active connection' });
    }
  } catch (e) { 
    console.error('Disconnect error:', e);
    res.status(500).json({ error: e.message }); 
  }
});

// OLD /api/send route - REMOVED (duplicate with multi-device version below)

// Communication toggle - updated for multi-device support
app.post('/api/comm-mode', (req, res) => {
  try {
    const mode = String((req.body && req.body.mode) || '').toLowerCase();
    if (!['wired','wifi'].includes(mode)) throw new Error('mode must be wired or wifi');
    
    if (mode === 'wired') {
      // Send WIRED_ONLY true to all devices
      if (devices.length > 0) {
        console.log(`üì¢ Broadcasting WIRED_ONLY true to all ${devices.length} devices`);
        sendToAll('WIRED_ONLY true\n');
      } else {
        send('WIRED_ONLY true\n');
      }
    } else { 
      // Send WIRED_ONLY false to all devices
      if (devices.length > 0) {
        console.log(`üì¢ Broadcasting WIRED_ONLY false to all ${devices.length} devices`);
        sendToAll('WIRED_ONLY false\n');
        // Also send WIFI_ON to all devices
        sendToAll('WIFI_ON\n');
      } else {
        send('WIRED_ONLY false\n');
        send('WIFI_ON\n');
      }
    }
    res.json({ ok: true, mode });
  } catch (e) { 
    console.error(`Error:`, e.message);
    res.status(400).json({ error: e.message }); 
  }
});

// Wi-Fi join + Windows scan
app.post('/api/wifi-join', (req, res) => {
  try {
    const { ssid, password, deviceId } = req.body || {};
    if (!ssid) throw new Error('Missing ssid');
    const esc = s => '"' + String(s).replace(/"/g, '\\"') + '"';
    const cmd = `WIFI_JOIN ${esc(ssid)} ${esc(password || '')}`;
    
    // Send WiFi credentials to ALL connected devices
    if (devices.length > 0) {
      console.log(`üì° Sending WiFi join to all ${devices.length} devices`);
      uiLog(`[WIFI] Sending: ${cmd}`);
      sendToAll(cmd + '\n');
      
      // Wait a moment for credentials to be saved before switching modes
      setTimeout(() => {
        uiLog('[WIFI] Switching to WiFi mode...');
        sendToAll('WIRED_ONLY false\n');
        
        setTimeout(() => {
          uiLog('[WIFI] Enabling WiFi...');
          sendToAll('WIFI_ON\n');
          
          setTimeout(() => {
            uiLog('[WIFI] Rebooting devices to connect...');
            sendToAll('REBOOT\n');
          }, 250);
        }, 250);
      }, 500);
    } else if (serial && serial.isOpen) {
      send(cmd + '\n');
      send('WIRED_ONLY false\n');
      send('REBOOT\n');
    } else {
      throw new Error('No devices connected - please connect TDS-8 devices first');
    }
    
    res.json({ ok: true });
  } catch (e) { 
    console.error(`‚ùå WiFi join error:`, e.message);
    res.status(400).json({ error: e.message }); 
  }
});

app.get('/api/wifi-scan', (_req, res) => {
  const isMac = process.platform === 'darwin';
  const isWin = process.platform === 'win32';
  
  if (!isMac && !isWin) {
    return res.status(500).json({ error: 'WiFi scan not supported on this platform' });
  }
  
  const scanCmd = isMac 
    ? 'networksetup -listpreferredwirelessnetworks en0 2>/dev/null'
    : 'netsh wlan show networks mode=Bssid';
  
  exec(scanCmd, { windowsHide: true, timeout: 10000 }, (err, stdout) => {
    if (err) { 
      console.error('WiFi scan error:', err);
      res.status(500).json({ error: err.message }); 
      return;
    }
    
    parseWiFiOutput(stdout, isMac, res);
  });
});

function parseWiFiOutput(stdout, isMac, res) {
  console.log('WiFi scan raw output:', stdout);
  const ssids = [];
  
  if (isMac) {
    // Parse Mac networksetup output: "Preferred networks on en0:\n\t\tSSID1\n\t\tSSID2"
    stdout.split(/\r?\n/).forEach(line => {
      const trimmed = line.trim();
      if (trimmed && !trimmed.startsWith('Preferred') && !trimmed.includes(':')) {
        if (!ssids.includes(trimmed)) ssids.push(trimmed);
      }
    });
  } else {
    // Parse Windows netsh output
    stdout.split(/\r?\n/).forEach(line => {
      const m = line.match(/^\s*SSID\s+\d+\s*:\s*(.+)$/i);
      if (m) { 
        const name = m[1].trim(); 
        if (name && !ssids.includes(name)) {
          console.log(`Found SSID: "${name}"`);
          ssids.push(name); 
        }
      }
    });
  }
  
  console.log(`üì° WiFi scan complete: ${ssids.length} networks found:`, ssids);
  res.json({ ok: true, ssids });
}

// GET /tracks - Return current track names for Ableton M4L
// Persist names to disk so they survive server restarts
const TRACK_NAMES_PATH = path.join(__dirname, 'tracknames.json');
let currentTrackNames = [
  'Track 1', 'Track 2', 'Track 3', 'Track 4',
  'Track 5', 'Track 6', 'Track 7', 'Track 8'
];
try {
  const raw = fs.readFileSync(TRACK_NAMES_PATH, 'utf8');
  const parsed = JSON.parse(raw);
  if (Array.isArray(parsed) && parsed.length === 8) {
    currentTrackNames = parsed.map(v => (typeof v === 'string' ? v : String(v || '')));
    console.log('‚úì Loaded track names from disk');
  }
} catch (e) {
  // No file yet or parse error; keep defaults silently
}

app.get('/tracks', (_req, res) => {
  res.json({ names: currentTrackNames });
});

// Tracks and active track
app.get('/api/tracknames', (req, res) => {
  try {
    const names = (currentTrackNames || []).map(n => {
      if (typeof n === 'string') return n;
      if (n && typeof n.name === 'string') return n.name;
      return '';
    });
    res.json({ ok: true, names });
  } catch (e) { res.status(400).json({ error: e.message }); }
});

// New endpoint to save all track names to a file
app.post('/api/tracknames', (req, res) => {
    const { names } = req.body;
    if (!Array.isArray(names)) {
        return res.status(400).json({ ok: false, error: 'Invalid data format' });
    }

    const filePath = path.join(__dirname, 'track_names.json');
    const data = JSON.stringify({ names }, null, 2);

    fs.writeFile(filePath, data, 'utf8', (err) => {
        if (err) {
            console.error('‚ùå Error saving track names:', err);
            return res.status(500).json({ ok: false, error: 'Failed to save track names' });
        }
        console.log('üíæ Track names saved to track_names.json');
        res.json({ ok: true });
    });
});

app.post('/api/trackname', (req, res) => {
  try {
    const { index, name, actualTrack } = req.body || {};
    
    // Debug: log exactly what we received
    console.log('üîç [DEBUG] Received trackname request:', {
      index,
      name,
      nameType: typeof name,
      nameLength: name ? name.length : 0,
      actualTrack
    });
    
    if (index === undefined || `${index}`.trim() === '') throw new Error('Missing index');
    // Allow empty string name to clear display; only require the field to be present
    if (name === undefined) throw new Error('Missing name');
    if (index >= 0 && index < 8) currentTrackNames[index] = String(name);
    
    // Build safe, quoted name and always include actualTrack (device adds +1, so default to index)
    const esc = String(name).replace(/"/g, '\\"');
    const at = (actualTrack !== undefined) ? actualTrack : Number(index);
    const cmd = `/trackname ${index} "${esc}" ${at}\n`;
    
    // Calculate which device should receive this track (based on actualTrack)
    const targetDeviceId = Math.floor(at / 8);
    // If UI sends during refresh window, close the window to enforce a single path
    const now = Date.now();
    if (now < trackAcceptUntil) {
      console.log('üîí /api/trackname received during Refresh window ‚Äî closing window to avoid duplicate paths');
      trackAcceptUntil = 0;
      if (refreshRouting) refreshRouting.active = false;
    }

    // Track-level dedupe across sources (UI+OSC)
    const trackKey = `${targetDeviceId}:${at}`;
    const prevSend = trackSendMap.get(trackKey);
    if (prevSend && prevSend.name === String(name) && (now - prevSend.at) < 500) {
      console.log(`‚è≠Ô∏è  track-dedupe (API) for device ${targetDeviceId}, track ${at}, name "${String(name)}"`);
      return res.json({ ok: true, deduped: true });
    }
    
    console.log('üì§ [TRACKNAME] Routing:', {
      index,
      name: name,
      actualTrack: at,
      targetDeviceId,
      devicesCount: devices.length,
      availableDevices: devices.map(d => `ID=${d.deviceID}`).join(', ')
    });
    
    // Route to correct device if multi-device mode
    if (devices.length > 1) {
      console.log(`üîç [ROUTING] Looking for deviceId=${targetDeviceId} for track ${at}`);
      const targetDevice = devices.find(d => d.deviceID === targetDeviceId || d.id === targetDeviceId);
      if (targetDevice) {
        sendToDevice(targetDevice.id, cmd, 'API');
        trackSendMap.set(trackKey, { name: String(name), at: Date.now() });
        console.log(`üì§ [Device ${targetDeviceId}] ${targetDevice.path} ‚Üê Track ${at}: "${name}"`);
      } else {
        console.warn(`‚ö†Ô∏è Device ${targetDeviceId} not found for track ${at}. Available:`, devices.map(d => `[ID=${d.deviceID}, path=${d.path}]`).join(', '));
        console.warn(`‚ö†Ô∏è Falling back to first connected device`);
        if (devices.length > 0) {
          sendToDevice(devices[0].id, cmd, 'API');
          trackSendMap.set(trackKey, { name: String(name), at: Date.now() });
          console.log(`üì§ [Device ${devices[0].deviceID}] ${devices[0].path} ‚Üê Track ${at}: "${name}"`);
        } else if (serial && serial.isOpen) {
          send(cmd);
          console.log(`üì§ [Serial] ‚Üê Track ${at}: "${name}"`);
        } else {
          throw new Error('No connected device to send trackname');
        }
      }
    } else {
      // Single device mode: prefer multi-device pipe if available
      if (devices.length > 0) {
        const d0 = devices[0];
        sendToDevice(d0.id, cmd, 'API');
        trackSendMap.set(trackKey, { name: String(name), at: Date.now() });
        console.log(`üì§ [Device ${d0.deviceID}] ${d0.path} ‚Üê Track ${at}: "${name}"`);
      } else if (serial && serial.isOpen) {
        // Legacy single-serial fallback
        send(cmd);
        console.log(`üì§ [Serial] ‚Üê Track ${at}: "${name}"`);
      } else {
        throw new Error('No connected device to send trackname');
      }
    }
    
    // Persist asynchronously; ignore errors
    try { fs.promises.writeFile(TRACK_NAMES_PATH, JSON.stringify(currentTrackNames, null, 2), 'utf8'); } catch {}
    res.json({ ok: true });
  } catch (e) { 
    console.error('‚ùå /api/trackname error:', e);
    res.status(400).json({ error: e.message }); 
  }
});
app.post('/api/activetrack', (req, res) => {
  try {
    const { index } = req.body || {};
    if (index === undefined || `${index}`.trim() === '') throw new Error('Missing index');
    
    // Send to all connected devices (activetrack is typically broadcast)
    if (devices.length > 0) {
      console.log(`üì¢ Broadcasting ACTIVETRACK ${index} to all ${devices.length} devices`);
      sendToAll(`/activetrack ${index}\n`);
    } else {
      send(`/activetrack ${index}\n`);
    }
    
    res.json({ ok: true });
  } catch (e) { res.status(400).json({ error: e.message }); }
});

app.post('/api/send', (req, res) => {
    try {
        const { cmd } = req.body;
        if (!cmd) throw new Error('Missing cmd');

        const upperCmd = cmd.toUpperCase().trim();
        
        // Handle VERSION commands
        if (upperCmd.startsWith('VERSION')) {
            const parts = upperCmd.split(/\s+/);
            
            // VERSION or VERSION ALL ‚Üí query all devices
            if (parts.length === 1 || (parts.length === 2 && parts[1] === 'ALL')) {
                if (devices.length === 0) {
                    throw new Error('No devices connected');
                }
                console.log(`üì¢ Broadcasting VERSION to all ${devices.length} devices`);
                sendToAll('VERSION\n');
                return res.json({ ok: true, message: `VERSION sent to all ${devices.length} devices` });
            }
            
            // VERSION <number> ‚Üí query specific device
            if (parts.length === 2) {
                const deviceNum = parseInt(parts[1]);
                if (isNaN(deviceNum)) {
                    throw new Error(`Invalid device number: ${parts[1]}`);
                }
                
                // Device numbers are 1-indexed for user (Device 1, Device 2, etc.)
                // But device IDs are 0-indexed internally (ID 0, ID 1, etc.)
                const deviceId = deviceNum - 1;
                
                const targetDevice = devices.find(d => d.id === deviceId);
                if (!targetDevice) {
                    throw new Error(`Device ${deviceNum} not found or not connected`);
                }
                
                console.log(`üìã Requesting VERSION from Device ${deviceNum} (ID: ${deviceId})`);
                sendToDevice(deviceId, 'VERSION\n');
                return res.json({ ok: true, message: `VERSION request sent to Device ${deviceNum}` });
            }
            
            throw new Error('Invalid VERSION syntax. Use: VERSION, VERSION ALL, or VERSION <number>');
        }
        
        // Handle WIRED_ONLY <true|false> (always broadcast)
        if (upperCmd.startsWith('WIRED_ONLY')) {
            const parts = cmd.trim().split(/\s+/);
            const arg = parts.length >= 2 ? parts[1] : undefined;
            if (arg === undefined) {
                throw new Error("Missing argument. Use: WIRED_ONLY true|false");
            }
            if (!/^(true|false)$/i.test(arg)) {
                throw new Error("Invalid argument. Use: WIRED_ONLY true|false");
            }
            if (devices.length === 0) throw new Error('No devices connected');
            console.log(`üì¢ Broadcasting WIRED_ONLY ${arg} to all ${devices.length} devices`);
            sendToAll(`WIRED_ONLY ${arg}\n`);
            // Transparency log to UI
            const mode = /^true$/i.test(arg) ? 'WIRED' : 'WIFI';
            const ip = mode === 'WIRED' ? '127.0.0.1' : (deviceIP || 'pending‚Ä¶');
            uiLog(`MODE: ${mode}`);
            uiLog(`IP: ${ip}`);
            uiLog(`OSC: Bridge listening ${OSC_LISTEN_PORT} (from M4L), sending ${M4L_PORT} (to M4L)`);
            return res.json({ ok: true, message: `WIRED_ONLY ${arg} sent to all devices` });
        }

        // Handle /reannounce command (send OSC to M4L)
        if (upperCmd === '/REANNOUNCE') {
            console.log('üì° Sending /reannounce OSC to M4L');
            try {
                sendOSC('/reannounce', []);
                return res.json({ ok: true, message: '/reannounce sent to M4L via OSC' });
            } catch (err) {
                return res.status(400).json({ error: `Failed to send /reannounce: ${err.message}` });
            }
        }
        
        // Handle REBOOT commands
        if (upperCmd.startsWith('REBOOT')) {
            const parts = upperCmd.split(/\s+/);
            
            // REBOOT or REBOOT ALL ‚Üí reboot all devices
            if (parts.length === 1 || (parts.length === 2 && parts[1] === 'ALL')) {
                if (devices.length === 0) {
                    throw new Error('No devices connected to reboot');
                }
                console.log(`üì¢ Rebooting all ${devices.length} devices`);
                sendToAll('REBOOT\n');
                return res.json({ ok: true, message: `Reboot command sent to all ${devices.length} devices` });
            }
            
            // REBOOT <number> ‚Üí reboot specific device
            if (parts.length === 2) {
                const deviceNum = parseInt(parts[1]);
                if (isNaN(deviceNum)) {
                    throw new Error(`Invalid device number: ${parts[1]}`);
                }
                
                // Device numbers are 1-indexed for user (Device 1, Device 2, etc.)
                // But device IDs are 0-indexed internally (ID 0, ID 1, etc.)
                const deviceId = deviceNum - 1;
                
                console.log(`üîç [DEBUG] Looking for Device ${deviceNum} (deviceId=${deviceId})`);
                console.log(`üîç [DEBUG] Available devices:`, devices.map(d => `[id=${d.id}, path=${d.path}]`).join(', '));
                
                const targetDevice = devices.find(d => d.id === deviceId);
                if (!targetDevice) {
                    throw new Error(`Device ${deviceNum} not found or not connected. Available devices: ${devices.map(d => `Device ${d.id + 1}`).join(', ')}`);
                }
                
                console.log(`üîÑ Rebooting Device ${deviceNum} (ID: ${deviceId}) on path: ${targetDevice.path}`);
                sendToDevice(deviceId, 'REBOOT\n');
                return res.json({ ok: true, message: `Reboot command sent to Device ${deviceNum}` });
            }
            
            throw new Error('Invalid REBOOT syntax. Use: REBOOT, REBOOT ALL, or REBOOT <number>');
        }
        
        // Other commands: send to first device as default (explicit broadcast not defined)
        if (devices.length > 0) {
            sendToDevice(devices[0].id, cmd + '\n');
            res.json({ ok: true, message: `Command sent to device ${devices[0].id}.` });
        } else {
            throw new Error('No devices connected to send command.');
        }
    } catch (e) {
        res.status(400).json({ error: e.message });
    }
});

// Send arbitrary OSC message to M4L
app.post('/api/osc-send', (req, res) => {
  try {
    const { address, args } = req.body || {};
    if (!address) throw new Error('Missing OSC address');
    
    const port = initOSC();
    if (!port) throw new Error('OSC not initialized');
    
    // Build OSC message
    const oscMsg = {
      address: address,
      args: args && Array.isArray(args) ? args.map(arg => ({
        type: typeof arg === 'number' ? (Number.isInteger(arg) ? 'i' : 'f') : 's',
        value: arg
      })) : []
    };
    
    port.send(oscMsg, M4L_IP, M4L_PORT);
    const logMessage = `üì° OSC sent to M4L: ${address} ${args ? args.join(' ') : ''}`;
    console.log(logMessage);
    wsBroadcast({ type: 'log', level: 'info', message: logMessage });
    
    res.json({ ok: true, message: `Sent ${address} to M4L` });
  } catch (e) { 
    console.error('OSC send error:', e.message);
    res.status(400).json({ ok: false, error: e.message }); 
  }
});

// Broadcast IP update to M4L
app.post('/api/broadcast-ip', (req, res) => {
  try {
    const { ip, mode } = (req.body || {});
    if (ip) {
      deviceIP = ip;
      wsBroadcast({ type: 'device-mode', mode: (mode || (ip === '127.0.0.1' ? 'wired' : 'wifi')), ip });
    }
    broadcastIPUpdate(ip || undefined, mode || undefined);
    res.json({ ok: true, message: 'Broadcast sent to M4L' });
  } catch (e) { res.status(400).json({ error: e.message }); }
});

// Get current device status
app.get('/api/device-status', (req, res) => {
  const connectionType = deviceIP === '127.0.0.1' ? 'wired' : (deviceIP ? 'wifi' : 'none');
  res.json({ 
    ok: true, 
    ip: deviceIP || '‚Äî',
    connectionType: connectionType,
    devices: devices.map(d => ({
      id: d.id,
      path: d.path,
      mode: d.connectionMode || 'wired',
      ip: d.ip || '127.0.0.1',
      version: d.version
    }))
  });
});

// Diagnostic endpoint - check OSC port status
app.get('/api/osc-status', (req, res) => {
  const now = Date.now();
  const timeSinceLastHi = lastHiTime ? now - lastHiTime : null;
  const abletonConnected = timeSinceLastHi !== null && timeSinceLastHi < 30000;
  
  const socketReady = udpPort && udpPort.socket && udpPort.socket._handle ? true : false;
  
  res.json({
    ok: true,
    oscSenderPort: 9001,
    oscListenerPort: OSC_LISTEN_PORT,
    deviceListenerPort: 9000,
    m4lTargetPort: M4L_PORT,
    m4lTargetIP: M4L_IP,
    lastHiReceived: lastHiTime ? new Date(lastHiTime).toISOString() : 'Never',
    timeSinceLastHi: timeSinceLastHi ? `${Math.floor(timeSinceLastHi / 1000)}s ago` : 'Never',
    abletonConnected: abletonConnected,
    udpPortInitialized: udpPort !== null,
    udpSocketReady: socketReady,
    oscListenerInitialized: oscListener !== null,
    connectedDevices: devices.length,
    deviceList: devices.map(d => ({ id: d.deviceID, path: d.path, version: d.version }))
  });
  
  console.log('üîç [OSC STATUS] Diagnostic check:', {
    abletonConnected,
    lastHi: lastHiTime ? `${Math.floor(timeSinceLastHi / 1000)}s ago` : 'Never',
    oscSenderReady: socketReady,
    oscListenerReady: oscListener !== null,
    connectedDevices: devices.length
  });
});

// Test endpoint - manually send /hello to M4L
app.post('/api/osc-test', (req, res) => {
  console.log('üß™ [TEST] Manually sending /hello to M4L...');
  try {
    sendOSC('/hello', []);
    res.json({ ok: true, message: 'Sent /hello to M4L - check console for response' });
  } catch (e) {
    res.status(500).json({ ok: false, error: e.message });
  }
});

// Firmware ‚Äî check single manifest
app.get('/api/ota-check', async (req, res) => {
  try {
    const manifestUrl = req.query.manifest || OTA_MANIFEST_URL;
    
    // Try local manifest first if no URL or GitHub URL
    if (!manifestUrl || manifestUrl.includes('github.com')) {
      try {
        const localManifest = JSON.parse(await fs.promises.readFile(path.join(__dirname, 'manifest.json'), 'utf8'));
        const newer = deviceVersion ? compareVersions(localManifest.version, deviceVersion) > 0 : null;
        return res.json({ ok: true, manifest: localManifest, deviceVersion, isNewer: newer, source: 'local' });
      } catch (localErr) {
        console.log('Local manifest not found:', localErr.message);
        if (!manifestUrl) {
          return res.json({ ok: false, error: 'No manifest URL configured and no local manifest found', deviceVersion });
        }
        // Continue to try remote URL
      }
    }
    
    // Try fetching from remote URL
    const mPath = await fetchToTemp(manifestUrl);
    const manifest = JSON.parse(await fs.promises.readFile(mPath, 'utf8'));
    const newer = deviceVersion ? compareVersions(manifest.version, deviceVersion) > 0 : null;
    res.json({ ok: true, manifest, deviceVersion, isNewer: newer, source: 'remote' });
  } catch (e) { res.status(400).json({ error: e.message }); }
});

// Firmware ‚Äî load a feed of versions (optional)

// New endpoint to switch all devices to WiFi mode
app.post('/api/wifi-switch-all', async (req, res) => {
  try {
    console.log('Broadcasting WiFi switch to all devices...');
    sendToAll('WIRED_ONLY false\n');
    sendToAll('WIFI_ON\n');
    // Add a small delay before rebooting to ensure the command is processed
    setTimeout(() => {
      sendToAll('REBOOT\n');
    }, 500);
    res.json({ ok: true, message: 'WiFi switch and reboot commands sent to all devices.' });
  } catch (e) {
    res.status(500).json({ error: e.message });
  }
});

// Firmware ‚Äî start OTA from a manifest - updated for multi-device support
app.post('/api/ota-update', async (req, res) => {
  try {
    const manifestUrl = (req.body && req.body.manifest) || OTA_MANIFEST_URL;
    if (!manifestUrl) throw new Error('No manifest URL provided');
    const mPath = await fetchToTemp(manifestUrl);
    const manifest = JSON.parse(await fs.promises.readFile(mPath, 'utf8'));
    if (!manifest.url) throw new Error('Manifest missing url');
    
    // Send OTA commands to all connected devices
    if (devices.length > 0) {
      console.log(`üì° Broadcasting OTA update to all ${devices.length} devices`);
      sendToAll('WIRED_ONLY false\n');
      sendToAll('WIFI_ON\n');
      sendToAll(`OTA_URL ${manifest.url}\n`);
    } else {
      send('WIRED_ONLY false\n');
      send('WIFI_ON\n');
      send(`OTA_URL ${manifest.url}\n`);
    }
    
    res.json({ ok: true, url: manifest.url });
  } catch (e) { res.status(400).json({ error: e.message }); }
});

// -------- Utils --------
async function fetchToTemp(url) {
  const { request } = await (url.startsWith('https:') ? import('node:https') : import('node:http'));
  const tmp = path.join(require('os').tmpdir(), 'tds8-' + Date.now() + '-' + Math.random().toString(16).slice(2));
  await new Promise((resolve, reject) => {
    const req = request(url, resp => {
      if (resp.statusCode < 200 || resp.statusCode >= 300) { reject(new Error('HTTP ' + resp.statusCode)); return; }
      const f = fs.createWriteStream(tmp);
      resp.pipe(f);
      f.on('finish', () => f.close(resolve));
    });
    req.on('error', reject);
    req.end();
  });
  return tmp;
}

function compareVersions(a, b) {
  const pa = String(a).split('.').map(n => parseInt(n, 10));
  const pb = String(b).split('.').map(n => parseInt(n, 10));
  const len = Math.max(pa.length, pb.length);
  for (let i = 0; i < len; i++) { const da = pa[i] || 0, db = pb[i] || 0; if (da > db) return 1; if (da < db) return -1; }
  return 0;
}

wss.on('connection', ws => {
  ws.send(JSON.stringify({ type: 'hello', port: serialPath, baud: BAUD }));
  try {
    const msg1 = `OSC: Bridge listening ${OSC_LISTEN_PORT} (from M4L), sending ${M4L_PORT} (to M4L)`;
    const msg2 = `Device Listener: 0.0.0.0:9000 (receives /ipupdate from TDS-8)`;
    const msg3 = `OSC Sender: 127.0.0.1:9001 -> ${M4L_IP}:${M4L_PORT}`;
    ws.send(JSON.stringify({ type: 'serial-data', data: msg1 }));
    ws.send(JSON.stringify({ type: 'serial-data', data: msg2 }));
    ws.send(JSON.stringify({ type: 'serial-data', data: msg3 }));
    // Push current Ableton status immediately to this client
    ws.send(JSON.stringify({ type: abletonConnected ? 'ableton-connected' : 'ableton-disconnected' }));
  } catch {}
});

// Auto-connect to all TDS-8 devices
async function autoConnectDevices() {
  try {
    const ports = await listPorts();
    const tds8Ports = ports.filter(p => {
      const mfg = (p.manufacturer || '').toLowerCase();
      const desc = (p.pnpId || '').toLowerCase();
      const vendor = (p.vendorId || '').toLowerCase();
      const product = (p.productId || '').toLowerCase();
      
      // XIAO ESP32-C3 uses CP2102N USB-to-UART bridge
      // VID: 10C4 (Silicon Labs), PID: EA60 (CP210x)
      const isCP2102 = vendor === '10c4' && product === 'ea60';
      const hasCP210x = mfg.includes('silicon labs') || desc.includes('cp210');
      
      return isCP2102 || hasCP210x;
    });
    
    console.log(`üîç Found ${tds8Ports.length} potential TDS-8 device(s)`);
    
    for (const port of tds8Ports) {
      // Check if already connected
      const alreadyConnected = devices.find(d => d.path === port.path);
      if (alreadyConnected) {
        console.log(`‚è≠Ô∏è  ${port.path} already connected as Device ${alreadyConnected.id + 1}`);
        continue;
      }
      
      // Determine device ID: check port mapping first, then assign next available
      let deviceId;
      if (portToDeviceId.has(port.path)) {
        // This port has been used before - restore its ID
        deviceId = portToDeviceId.get(port.path);
        console.log(`üìå Auto-connect restoring Device ID ${deviceId} for ${port.path} (previously assigned)`);
      } else {
        // New port - assign next available ID (0-3)
        const usedIds = new Set(Array.from(portToDeviceId.values()));
        for (let i = 0; i < MAX_DEVICES; i++) {
          if (!usedIds.has(i)) {
            deviceId = i;
            break;
          }
        }
        portToDeviceId.set(port.path, deviceId);
        console.log(`üÜï Auto-connect assigning new Device ID ${deviceId} to ${port.path}`);
      }
      
      console.log(`üîå Auto-connecting ${port.path} as Device ${deviceId + 1}...`);
      
      try {
        const newSerial = new SerialPortStream({ binding: Bindings, path: port.path, baudRate: BAUD });
        
        const device = {
          id: deviceId,
          serial: newSerial,
          path: port.path,
          buffer: '',
          version: null,
          deviceID: deviceId
        };
        
        devices.push(device);
        
        // Set up data handler for this device (guard against duplicate attach)
        try { newSerial.removeAllListeners && newSerial.removeAllListeners('data'); } catch {}
        if (!newSerial.__tds8DataAttached) {
          newSerial.on('data', (chunk) => onSerialDataMulti(device, chunk));
          newSerial.__tds8DataAttached = true;
        }
        newSerial.on('error', e => {
          console.error(`‚ùå Device ${deviceId} error:`, e.message);
        });
        newSerial.on('close', () => {
          console.log(`üîå Device ${deviceId} disconnected: ${port.path}`);
          const index = devices.findIndex(d => d.id === deviceId);
          if (index !== -1) devices.splice(index, 1);
        });
        
        // Send DEVICE_ID and VERSION commands with retry
        setTimeout(() => {
          sendToDevice(deviceId, `DEVICE_ID ${deviceId}\n`);
          sendToDevice(deviceId, 'VERSION\n');
          console.log(`‚úÖ Auto-connected: ${port.path} ‚Üí Device ${deviceId + 1} (Tracks ${deviceId * 8 + 1}-${(deviceId + 1) * 8})`);
          wsBroadcast({ type: 'device-connected', deviceId, path: port.path, trackRange: `${deviceId * 8 + 1}-${(deviceId + 1) * 8}` });
          
          // Retry VERSION command if no response after 3 seconds
          setTimeout(() => {
            if (!devices.find(d => d.id === deviceId && d.version)) {
              console.log(`üîÑ Retrying VERSION for Device ${deviceId + 1} (no response yet)`);
              sendToDevice(deviceId, 'VERSION\n');
            }
          }, 3000);
        }, 1000);
        
      } catch (err) {
        console.error(`‚ùå Failed to auto-connect ${port.path}:`, err.message);
      }
    }
  } catch (err) {
    console.error('‚ùå Auto-connect failed:', err.message);
  }
}

server.listen(PORT, () => {
  console.log('\n========================================================');
  console.log('         TDS-8 Bridge - Port Configuration');
  console.log('========================================================');
  console.log(`  HTTP Server:    http://localhost:${PORT}`);
  console.log(`  OSC Listener:   0.0.0.0:${OSC_LISTEN_PORT} (receives from M4L)`);
  console.log(`  OSC Sender:     127.0.0.1:9001 -> 127.0.0.1:${M4L_PORT}`);
  console.log('  WebSocket:      ws://localhost:8088');
  console.log('========================================================');
  console.log(`  M4L should send OSC to: 127.0.0.1:${OSC_LISTEN_PORT}`);
  console.log(`  M4L should listen on:   port ${M4L_PORT}`);
  console.log('========================================================\n');
  
  // Auto-connect disabled - user connects manually via UI
  // setTimeout(autoConnectDevices, 2000);
  // setInterval(autoConnectDevices, 5000);
});
