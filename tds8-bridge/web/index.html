<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>TDS-8 Control</title>
<link rel="icon" type="image/svg+xml" href="/favicon.svg">
<style>
:root{--brand:#ff8800;--brand2:#8a2be2;--text:#222;--muted:#666;--card:#fff;--bg:#f6f7fb;--hover:#f0f1f5}
*{box-sizing:border-box}
body{margin:0;background:var(--bg);font:14px/1.3 system-ui,Segoe UI,Roboto;color:var(--text);overflow:hidden}
.wrap{max-width:100%;height:100vh;display:flex;flex-direction:column;padding:12px}
.main-grid{display:grid;grid-template-columns:1fr 380px;gap:12px;flex:1;min-height:0}
.left-col{display:flex;flex-direction:column;gap:12px;overflow-y:auto}
.right-col{display:flex;flex-direction:column;min-height:0}
.card{background:var(--card);border-radius:10px;box-shadow:0 4px 12px rgba(0,0,0,.06);overflow:hidden}
.card.flex{display:flex;flex-direction:column;flex:1;min-height:0}
.hdr{background:linear-gradient(135deg,var(--brand),var(--brand2));padding:12px 16px;color:#fff}
.hdr h1{margin:0;font-size:16px;font-weight:600}
.body{padding:16px}
.body.flex{flex:1;min-height:0;display:flex;flex-direction:column}
.grid{display:grid;grid-template-columns:1fr 1fr;gap:10px}
.grid3{display:grid;grid-template-columns:1fr 1fr;gap:10px}
label{display:block;color:var(--text);font-size:13px;font-weight:500;margin-bottom:6px}
.input{padding:8px 10px;border:2px solid #e3e6ef;border-radius:8px;background:#fff;width:100%;font-size:13px;transition:all .2s}
.input:focus{outline:none;border-color:var(--brand);box-shadow:0 0 0 2px rgba(255,136,0,.1)}
select.input{cursor:pointer}
.btn{appearance:none;border:0;border-radius:8px;padding:8px 14px;cursor:pointer;font-size:13px;font-weight:500;transition:all .2s;display:inline-flex;align-items:center;justify-content:center;gap:6px}
.btn:hover{transform:translateY(-1px);box-shadow:0 3px 8px rgba(0,0,0,.12)}
.btn:active{transform:translateY(0)}
.btn.primary{background:var(--brand);color:#fff}
.btn.primary:hover{background:#ff9920}
.btn.secondary{background:var(--brand2);color:#fff}
.btn.secondary:hover{background:#9b3bf3}
.btn.ghost{background:#fff;border:2px solid #e3e6ef;color:var(--text)}
.btn.ghost:hover{background:var(--hover);border-color:#d0d3df}
.btn.ghost.active{background:var(--brand);color:#fff;border-color:var(--brand)}
.btn.sm{padding:6px 10px;font-size:12px}
.btn-group{display:flex;gap:8px;flex-wrap:wrap}
.device-list{display:flex;flex-direction:column;gap:6px}
.device-item{background:#f3f4f6;border:2px solid #d1d5db;border-radius:8px;padding:10px 12px;display:flex;justify-content:space-between;align-items:center;transition:all .2s;opacity:0.6}
.device-item:hover{border-color:var(--brand);background:#fff;opacity:1}
.device-item.connected{border-color:var(--brand);background:#fff8f0;opacity:1}
.device-name{font-weight:600;font-size:14px;color:var(--text)}
.device-status{font-size:11px;color:#10b981;margin-top:2px}
.trackgrid{display:grid;grid-template-columns:repeat(2,1fr);gap:4px;max-height:650px;overflow-y:scroll;padding-right:8px}
.trackrow{display:flex;gap:6px;align-items:center}
.trackrow label{margin:0;min-width:60px;font-weight:600;font-size:12px;color:var(--text)}
.trackrow .input{padding:5px 8px;font-size:12px}
.track-sep{grid-column:1 / -1;height:6px;border-radius:6px;margin:6px 0;background:linear-gradient(90deg,#ff8800 0%, #8a2be2 100%);opacity:0.3}
.serial-card{max-height:calc(100vh - 140px);display:flex;flex-direction:column}
.serial-card .body.flex{flex:1;min-height:0;display:flex;flex-direction:column}
.icon-card{text-align:center;padding:20px 16px;cursor:pointer;transition:all .2s;border-radius:8px;border:2px solid transparent}
.icon-card:hover{background:var(--hover);border-color:#e3e6ef;transform:translateY(-1px)}
.icon-card .icon{font-size:36px;margin-bottom:8px}
.icon-card h3{margin:0 0 4px;font-size:14px;font-weight:600}
.icon-card p{margin:0;font-size:11px;color:var(--muted);line-height:1.3}
.log{font-family:ui-monospace,Menlo,Consolas,monospace;background:#fafbff;color:var(--text);border:2px solid #e3e6ef;border-radius:8px;padding:12px;overflow-y:scroll;font-size:11px;line-height:1.5;flex:1;min-height:200px;max-height:100%}
.log::-webkit-scrollbar{width:12px}
.log::-webkit-scrollbar-track{background:#e3e6ef;border-radius:4px}
.log::-webkit-scrollbar-thumb{background:#999;border-radius:4px}
.log::-webkit-scrollbar-thumb:hover{background:#666}
.log-line{margin:1px 0}
.log-line.out{color:#10b981}
.log-line.err{color:#ef4444}
.helpbox{margin-top:10px;padding:10px 12px;border:2px solid #e3e6ef;border-radius:8px;background:#fafbff;font-size:11px;color:#444}
.helpbox code{background:#fff;border:1px solid #e3e6ef;border-radius:4px;padding:0 4px}
.divider{height:1px;background:#e3e6ef;margin:12px 0}
.notice{background:#fef3c7;border:2px solid #fbbf24;border-radius:8px;padding:10px 12px;font-size:12px;color:#92400e;margin-bottom:12px}
.network-item{display:flex;justify-content:space-between;align-items:center;padding:12px;background:#fafbff;border-bottom:1px solid #e3e6ef;transition:all .2s;cursor:pointer}
.network-item:hover{background:#fff}
.network-item:last-child{border-bottom:none}
.network-item .name{font-weight:500;font-size:14px;color:var(--text)}
.network-item .icon{font-size:20px;color:var(--muted)}
.network-item.saved .name{color:#e91e63}
.network-item.saved .icon{color:#e91e63}
.footer-info{text-align:center;padding:16px;background:#fafbff;border-top:1px solid #e3e6ef;font-size:11px;color:var(--muted)}
.footer-info .company{font-weight:600;color:var(--text);margin-bottom:4px}
.footer-info .serial{font-family:ui-monospace,monospace}
</style>
</head>
<body>
  <div class="wrap" style="display:block;" id="mainApp">
    <!-- Connection Status Banner -->
    <div id="connectionBanner" style="background:linear-gradient(135deg,#667eea 0%,#764ba2 100%);color:#fff;padding:12px 20px;margin-bottom:16px;border-radius:8px;display:flex;justify-content:space-between;align-items:center;box-shadow:0 2px 8px rgba(0,0,0,0.1)">
      <div style="display:flex;align-items:center;gap:16px">
        <div style="font-size:13px;font-weight:600;opacity:0.9">TDS-8 Connection:</div>
        <div id="connectionType" style="font-size:14px;font-weight:700;padding:4px 12px;background:rgba(255,255,255,0.2);border-radius:4px;border:1px solid rgba(255,255,255,0.3)">Not Connected</div>
      </div>
      <div style="display:flex;align-items:center;gap:12px">
        <div style="font-size:11px;opacity:0.8">IP Address:</div>
        <div id="connectionIP" style="font-family:ui-monospace,monospace;font-size:13px;font-weight:600;padding:4px 10px;background:rgba(0,0,0,0.2);border-radius:4px">‚Äî</div>
      </div>
    </div>
    
    <div class="main-grid">
      <!-- Left Column -->
      <div class="left-col">
        
        <!-- Devices -->
        <div class="card">
          <div class="hdr" style="display:flex;justify-content:space-between;align-items:center">
            <h1>üéõÔ∏è TDS-8 Devices</h1>
            <div style="display:flex;gap:8px;align-items:center">
              <button id="btnFirmwareTop" class="btn secondary sm" title="Check for Firmware Updates" style="background:rgba(255,255,255,0.2);color:#fff;border:1px solid rgba(255,255,255,0.3);padding:4px 10px;font-size:11px">‚¨áÔ∏è Firmware</button>
              <button id="btnRefreshDevices" class="btn ghost sm" style="background:rgba(255,255,255,0.2);color:#fff;border:1px solid rgba(255,255,255,0.3);padding:4px 10px;font-size:11px">üîÑ Refresh</button>
            </div>
          </div>
          <div class="body">
            <div id="deviceList" class="device-list">
              <div style="text-align:center;padding:12px;color:var(--muted);font-size:12px">
                Scanning for devices...
              </div>
            </div>
            
            <!-- Alternate Connection Methods -->
            <div style="display:flex;gap:12px;margin-top:16px;padding-top:16px;border-top:2px solid #e3e6ef">
              <div style="flex:1">
                <div style="display:flex;align-items:center;gap:8px;margin-bottom:4px">
                  <label style="font-size:11px;color:var(--muted);font-weight:600;margin:0">üîå Alternate Wired COM Port</label>
                  <span id="wiredStatus" style="font-size:10px;padding:2px 8px;border-radius:4px;background:#e5e7eb;color:#6b7280">Disconnected</span>
                </div>
                <div style="display:flex;gap:8px;align-items:center">
                  <select id="comPortSelect" class="input" style="flex:1;font-size:12px;padding:6px 8px">
                    <option value="">Select COM port...</option>
                  </select>
                  <button id="btnWiredConnect" class="btn primary sm">Connect</button>
                </div>
              </div>
              <div style="flex:1">
                <div style="display:flex;align-items:center;gap:8px;margin-bottom:4px">
                  <label style="font-size:11px;color:var(--muted);font-weight:600;margin:0">üì° WiFi Connection</label>
                  <span id="wifiStatus" style="font-size:10px;padding:2px 8px;border-radius:4px;background:#e5e7eb;color:#6b7280">Disconnected</span>
                </div>
                <div style="display:flex;gap:8px;align-items:center">
                  <select id="wifiNetworkSelect" class="input" style="flex:1;font-size:12px;padding:6px 8px" title="Windows may only show currently connected network. Disconnect WiFi to see all networks.">
                    <option value="">Select WiFi network...</option>
                  </select>
                  <button id="btnWifiScanQuick" class="btn ghost sm" title="Scan for networks (may only show connected network on Windows)">üîÑ</button>
                  <button id="btnWifiConnect" class="btn primary sm">Connect</button>
                </div>
              </div>
            </div>
          </div>
        </div>

        <!-- Track Names -->
        <div class="card">
          <div class="hdr" style="display:flex;justify-content:space-between;align-items:center"><h1>üéµ Track Names</h1></div>
          <div class="body" style="display:flex;flex-direction:column;min-height:0;max-height:500px;overflow-y:auto;">
            <div class="btn-group" id="trackBtnGroup" style="margin-bottom:12px"></div>
            <!-- Offset Controls (hidden for now) -->
            <div style="display:none"></div>
            
            <div class="trackgrid" id="tracks" style="overflow-y:auto;max-height:320px;"></div>
            <div class="divider"></div>
            <div class="btn-group" style="margin-bottom:8px">
              <button id="btnRefresh" class="btn primary">üîÑ Refresh from Ableton</button>
              <button id="btnSendAll" class="btn ghost sm">Update All Tracks</button>
              <button id="btnResetTracks" class="btn ghost sm">Clear All Tracks</button>
              <button id="btnSaveTracks" class="btn secondary sm">Save Current Tracks</button>
              <button id="btnReadTracks" class="btn secondary sm">Load Stored Tracks</button>
            </div>
          </div>
        </div>

      </div>

      <!-- Right Column - Serial Monitor -->
      <div class="right-col">
        <div class="card flex serial-card">
          <div class="hdr">
            <h1>üìü Serial Monitor</h1>
            <label style="display:flex;align-items:center;gap:6px;font-size:12px;margin-left:auto;cursor:pointer">
              <input type="checkbox" id="autoScroll" checked style="cursor:pointer"/>
              Auto-scroll
            </label>
          </div>
          <div class="body flex">
            <div id="log" class="log"></div>
            <div style="margin-top:10px;display:flex;gap:8px">
              <input id="cmd" class="input" placeholder="Send command..." style="flex:1;font-size:12px;padding:6px 8px" autocomplete="off"/>
              <button id="btnSend" class="btn ghost sm">Send</button>
            </div>
            <div class="helpbox">
              <div style="font-weight:600;margin-bottom:6px">Commands quick reference</div>
              <div>VERSION - request version</div>
              <div>REBOOT - reboot device</div>
              <div style="margin-top:12px;font-weight:600">Ableton Messages over OSC</div>
              <div><code>/reannounce</code></div>
              <div><code>/hello</code></div>
              <div><code>/trackname index "Name" actualTrack</code> - Example: <code>/trackname 0 "Kick" 0</code></div>
              <div><code>/ipupdate</code> - device IP update (WiFi mode)</div>
            </div>
          </div>
        </div>
      </div>

    </div>
    
    <!-- Footer -->
    <div class="footer-info">
      <div class="company">PlayOptix, LLC</div>
      <div class="serial" id="footerSerial">Serial Number: Loading...</div>
    </div>
  </div>

  <!-- Wi-Fi Modal -->
  <div id="modalWifi" style="display:none;position:fixed;top:0;left:0;right:0;bottom:0;background:rgba(0,0,0,.5);z-index:1000;padding:20px;overflow:auto">
    <div style="max-width:600px;margin:60px auto;background:white;border-radius:10px;overflow:hidden">
      <div class="hdr"><h1>üì° Wi-Fi Settings</h1></div>
      <div class="body" style="padding:0">
        <div style="padding:16px">
          <div class="notice">
            ‚ö†Ô∏è Connecting to Wi-Fi will disable wired mode. Device will switch to wireless communication.
          </div>
          
          <div style="margin-bottom:12px">
            <label style="padding:0 0 8px 0">Add New Network</label>
            <div style="font-size:12px;color:var(--muted);margin-bottom:12px">
              <span style="color:#000;font-weight:600">MANUALLY ADD NETWORK</span> ... Or choose a network from the list below.
            </div>
          </div>
        </div>
        
        <div id="networkList" style="max-height:300px;overflow-y:auto">
          <!-- Networks will be inserted here -->
        </div>
        
        <div style="padding:16px;border-top:1px solid #e3e6ef">
          <div class="btn-group">
            <button id="btnScanNetworks" class="btn secondary">Scan for Networks</button>
            <button id="btnAddNetwork" class="btn primary">Add Network</button>
            <button id="btnCloseWifi" class="btn ghost">Close</button>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Add Network Modal -->
  <div id="modalAddNetwork" style="display:none;position:fixed;top:0;left:0;right:0;bottom:0;background:rgba(0,0,0,.5);z-index:1001;padding:20px;overflow:auto">
    <div style="max-width:450px;margin:80px auto;background:white;border-radius:10px;overflow:hidden">
      <div class="hdr"><h1>‚ûï Add Network</h1></div>
      <div class="body">
        <label>Network Name (SSID)</label>
        <input id="ssidInput" class="input" placeholder="Enter network name" style="margin-bottom:12px"/>
        
        <label>Password</label>
        <input id="pwd" class="input" type="password" placeholder="Enter password" style="margin-bottom:16px"/>
        
        <div class="btn-group">
          <button id="btnSaveNetwork" class="btn primary">Save & Connect</button>
          <button id="btnCancelAdd" class="btn ghost">Cancel</button>
        </div>
      </div>
    </div>
  </div>

  <!-- Firmware Modal -->
  <div id="modalFirmware" style="display:none;position:fixed;top:0;left:0;right:0;bottom:0;background:rgba(0,0,0,.5);z-index:1000;padding:20px;overflow:auto">
    <div style="max-width:500px;margin:60px auto;background:white;border-radius:10px;overflow:hidden">
      <div class="hdr"><h1>‚¨áÔ∏è Firmware Updates</h1></div>
      <div class="body">
        <div id="firmwareStatus" style="text-align:center;padding:20px">
          <div style="font-size:48px;margin-bottom:12px">üîç</div>
          <p style="color:var(--muted);font-size:13px">Click Check for Updates to begin</p>
        </div>
        
        <div class="btn-group" style="justify-content:center">
          <button id="btnCheck" class="btn primary">Check for Updates</button>
          <button id="btnOta" class="btn secondary" style="display:none">Install Update</button>
          <button id="btnCloseFirmware" class="btn ghost">Close</button>
        </div>
      </div>
    </div>
  </div>

<script>
const $ = s => document.querySelector(s);
const logEl = $('#log');
let autoScrollEnabled = true;
const autoScrollCb = $('#autoScroll');
if (autoScrollCb) {
  autoScrollEnabled = !!autoScrollCb.checked;
  autoScrollCb.addEventListener('change', (e) => {
    autoScrollEnabled = !!e.target.checked;
    if (autoScrollEnabled && logEl) {
      requestAnimationFrame(() => { logEl.scrollTop = logEl.scrollHeight; });
    }
  });
}
// Periodically ensure we stay pinned to bottom when enabled
setInterval(() => {
  if (autoScrollEnabled && logEl) {
    logEl.scrollTop = logEl.scrollHeight;
  }
}, 500);
let connectedDevices = new Map();
let currentDevice = null;
let deviceCounter = 0;
let savedWifiNetworks = [];
let deviceSerialNumber = 'Unknown';
let currentConnectionType = 'none'; // 'none', 'wired', 'wifi'
let currentConnectionIP = '‚Äî';
let deviceVersions = new Map(); // Store firmware versions by port path
let deviceIdMap = new Map(); // Map serial numbers to device IDs for persistence

// Update connection status banner
function updateConnectionBanner(type, ip) {
  console.log(`üîÑ updateConnectionBanner called: type=${type}, ip=${ip}`);
  currentConnectionType = type;
  currentConnectionIP = ip || '‚Äî';
  
  const typeEl = $('#connectionType');
  const ipEl = $('#connectionIP');
  const banner = $('#connectionBanner');
  
  console.log(`üîç Elements found: typeEl=${!!typeEl}, ipEl=${!!ipEl}, banner=${!!banner}`);
  
  if (type === 'wired') {
    typeEl.textContent = 'üîå Wired (USB)';
    typeEl.style.background = 'rgba(16,185,129,0.3)';
    typeEl.style.border = '1px solid rgba(16,185,129,0.5)';
    banner.style.background = 'linear-gradient(135deg,#10b981 0%,#059669 100%)';
  } else if (type === 'wifi') {
    typeEl.textContent = 'üì° WiFi';
    typeEl.style.background = 'rgba(59,130,246,0.3)';
    typeEl.style.border = '1px solid rgba(59,130,246,0.5)';
    banner.style.background = 'linear-gradient(135deg,#3b82f6 0%,#2563eb 100%)';
  } else {
    typeEl.textContent = '‚ùå Not Connected';
    typeEl.style.background = 'rgba(239,68,68,0.3)';
    typeEl.style.border = '1px solid rgba(239,68,68,0.5)';
    banner.style.background = 'linear-gradient(135deg,#6b7280 0%,#4b5563 100%)';
  }
  
  ipEl.textContent = currentConnectionIP;
  console.log(`‚úÖ Banner updated: ${typeEl.textContent} - ${ipEl.textContent}`);
}

// Load saved networks from localStorage
function loadSavedNetworks() {
  const saved = localStorage.getItem('tds8_wifi_networks');
  if (saved) {
    try {
      savedWifiNetworks = JSON.parse(saved);
    } catch (e) {
      savedWifiNetworks = [];
    }
  }
}

function saveSavedNetworks() {
  localStorage.setItem('tds8_wifi_networks', JSON.stringify(savedWifiNetworks));
}

function log(msg, type = 'info') {
  const line = document.createElement('div');
  line.className = 'log-line ' + type;
  line.textContent = msg;
  logEl.appendChild(line);
  
  // Auto-scroll if enabled; do it after layout to ensure it sticks
  if (autoScrollEnabled) {
    logEl.scrollTop = logEl.scrollHeight;
    requestAnimationFrame(() => { logEl.scrollTop = logEl.scrollHeight; });
  }
}

function updateFooterSerial(serialNum) {
  deviceSerialNumber = serialNum || 'Unknown';
  $('#footerSerial').textContent = `Serial Number: ${deviceSerialNumber}`;
}

function updateConnectionStatus(connected) {
  const statusEl = $('#statusText');
  if (statusEl) {
    if (connected) {
      statusEl.textContent = 'üîå Connected';
      statusEl.style.color = '#10b981';
    } else {
      statusEl.textContent = 'Disconnected';
      statusEl.style.color = 'var(--muted)';
    }
  }
}

// ----- Device Management -----
async function scanDevices() {
  try {
    console.log('[scanDevices] Fetching /api/ports...');
    const res = await fetch('/api/ports');
    console.log(`[scanDevices] Response status: ${res.status}`);
    if (!res.ok) throw new Error(`Server error: ${res.status}`);
    const rawResponse = await res.text();
    console.log('[scanDevices] Raw response:', rawResponse);
    const ports = JSON.parse(rawResponse);
    console.log('[scanDevices] Parsed ports:', ports);
    const list = $('#deviceList');
    list.innerHTML = '';
    
    if (!Array.isArray(ports) || ports.length === 0) {
      list.innerHTML = '<div style="text-align:center;padding:12px;color:var(--muted);font-size:12px">No TDS-8 devices found. Please connect via USB.<br><small style="color:#888">Try clicking Refresh or use manual COM connect below.</small></div>';
      updateFooterSerial(null);
      return;
    }
  
  ports.forEach((p, idx) => {
    const item = document.createElement('div');
    item.className = 'device-item';
    const isConnected = connectedDevices.has(p.path);
    if (isConnected) item.classList.add('connected');
    
    const deviceNum = idx + 1;
    const deviceName = `TDS-8 #${deviceNum}`;
    
    // Show "TDS-8" with port name
    const portName = p.path.split('/').pop(); // Get last part of path (e.g., "cu.usbmodem101")
    const displayName = isConnected ? `TDS-8 (${portName})` : `${deviceName} (${portName})`;
    
    // Get firmware version and device info if available
    const version = deviceVersions.get(p.path);
    const versionBadge = version ? `<span style="font-size:10px;padding:2px 6px;background:#10b981;color:#fff;border-radius:4px;margin-left:8px">v${version}</span>` : '';
    
    // Get device ID and track range if connected
    const deviceInfo = connectedDevices.get(p.path);
    const trackInfo = deviceInfo ? ` - Tracks ${deviceInfo.trackRange}` : '';
    
    const statusText = isConnected 
      ? `<div class="device-status">‚úì Connected via USB${trackInfo}</div>` 
      : `<div style="font-size:11px;color:#6b7280;margin-top:2px">‚ö™ Disconnected</div>`;
    
    // Create device item HTML
    const deviceIdOptions = [0, 1, 2, 3].map(id => 
      `<option value="${id}" ${id === idx ? 'selected' : ''}>Tracks ${id * 8 + 1}-${(id + 1) * 8}</option>`
    ).join('');
    
    item.innerHTML = `
      <div style="display:flex;align-items:center;gap:12px;flex:1">
        <div>
          <div class="device-name">${displayName}${versionBadge}</div>
          ${statusText}
        </div>
      </div>
      <div style="display:flex;align-items:center;gap:8px">
        ${!isConnected ? 
          `<select class="input sm" style="width:140px;font-size:11px;padding:4px 6px" data-path="${p.path}">
            ${deviceIdOptions}
          </select>` : ''
        }
        ${isConnected ? 
          `<button class="btn ghost sm" onclick="disconnect('${p.path}')">Disconnect</button>` :
          `<button class="btn primary sm" onclick="connect('${p.path}', '${deviceName}', '${p.serialNumber || ''}')">Connect</button>`
        }
      </div>
    `;
    
    // Add click handler for device item
    item.onclick = (e) => {
      if (e.target.tagName !== 'BUTTON') {
        if (!isConnected) {
          connect(p.path, deviceName, p.serialNumber || '');
        }
      }
    };
    
    list.appendChild(item);
    
    // Update footer with serial number if connected
    if (isConnected && p.serialNumber) {
      updateFooterSerial(p.serialNumber);
    }
    
    // Device ID selector - priority: saved by serial -> connected info -> auto by list order
    let selectedDeviceId = null;
    if (p.serialNumber && deviceIdMap.has(p.serialNumber)) {
      selectedDeviceId = deviceIdMap.get(p.serialNumber);
    } else if (deviceInfo) {
      selectedDeviceId = deviceInfo.deviceId;
    } else {
      // Auto-assign next available ID (0-3)
      const usedIds = new Set(Array.from(deviceIdMap.values()));
      let deviceId = 0;
      while (usedIds.has(deviceId) && deviceId < 4) {
        deviceId++;
      }
      if (p.serialNumber) {
        deviceIdMap.set(p.serialNumber, deviceId);
        log(`üÜï Auto-assigned Device ID ${deviceId} to serial ${p.serialNumber}`, 'info');
      }
    }
    
  });
  
  // end of scanDevices list rendering
  } catch (err) {
    log(`‚úó Error scanning devices: ${err.message}`, 'err');
    console.error('Scan error:', err);
  }
}

async function connect(path, name, serialNum, retryCount = 0) {
  try {
    log(`üîå Connecting to ${name || path}...`, 'info');
    
    // Check if this device has a saved ID (by serial number) or manually selected ID
    let deviceId;
    
    // First check if user manually selected an ID via dropdown
    const selector = document.querySelector(`select[data-path="${path}"]`);
    const manualId = selector ? parseInt(selector.value) : null;
    
    if (manualId !== null && !isNaN(manualId)) {
      // Use manually selected ID
      deviceId = manualId;
      if (serialNum) {
        deviceIdMap.set(serialNum, deviceId);
      }
      log(`üëÜ Using manually selected Device ID ${deviceId}`, 'info');
    } else if (serialNum && deviceIdMap.has(serialNum)) {
      // Restore previously saved ID
      deviceId = deviceIdMap.get(serialNum);
      log(`üìå Restored Device ID ${deviceId} for serial ${serialNum}`, 'info');
    } else {
      // Auto-assign next available ID (0-3)
      const usedIds = new Set(Array.from(deviceIdMap.values()));
      deviceId = 0;
      while (usedIds.has(deviceId) && deviceId < 4) {
        deviceId++;
      }
      if (serialNum) {
        deviceIdMap.set(serialNum, deviceId);
        log(`üÜï Auto-assigned Device ID ${deviceId} to serial ${serialNum}`, 'info');
      }
    }
    
    const trackRange = `${deviceId * 8 + 1}-${(deviceId + 1) * 8}`;
    
    const res = await fetch('/api/connect', { 
      method:'POST', 
      headers:{'Content-Type':'application/json'}, 
      body: JSON.stringify({ path, deviceId }) // Pass device ID to backend
    });
    const j = await res.json();
    if (j.ok) {
      connectedDevices.set(path, { name, path, serialNum, deviceId, trackRange });
      currentDevice = path;
      updateFooterSerial(serialNum);
      updateConnectionStatus(true);
      updateConnectionBanner('wired', '127.0.0.1');
      
      // Backend now sends DEVICE_ID command, no need to send it here
      
      // Wait for version info before logging
      setTimeout(() => {
        const version = deviceVersions.get(path) || 'Unknown';
        log(`‚úì Connected to ${name || path} v${version} - Device ID ${deviceId} - Tracks ${trackRange}`, 'out');
      }, 1000);
      
      scanDevices();
      buildTrackGrid(); // Rebuild track grid with new device rows
      
      // Send track names for this device's range after connection
      setTimeout(async () => {
        await sendTrackNamesForDevice(deviceId);
      }, 1500);
    } else {
      log(`‚úó Connection failed: ${j.error || 'Unknown error'}`, 'err');
      // Only retry once
      if (retryCount < 1) {
        setTimeout(() => {
          log('üîÑ Retrying connection (1/1)...', 'info');
          connect(path, name, serialNum, retryCount + 1);
        }, 1000);
      } else {
        log('‚úó Connection failed after retry. Try manual COM port or click Refresh.', 'err');
      }
    }
  } catch (err) {
    log(`‚úó Connection error: ${err.message}`, 'err');
    console.error('Connect error:', err);
  }
}

function disconnect(path) {
  // Send disconnect request to server to release serial port
  fetch('/api/disconnect', {
    method: 'POST',
    headers: {'Content-Type': 'application/json'},
    body: JSON.stringify({ path })
  }).catch(err => console.error('Disconnect error:', err));
  
  connectedDevices.delete(path);
  if (currentDevice === path) {
    currentDevice = null;
    updateFooterSerial(null);
    updateConnectionStatus(false);
    updateConnectionBanner('none', '‚Äî');
    // Reset wired connection UI
    const wiredBtn = $('#btnWiredConnect');
    const comSelect = $('#comPortSelect');
    const wiredStatus = $('#wiredStatus');
    if (wiredBtn) {
      wiredBtn.textContent = 'Connect';
      wiredBtn.className = 'btn primary sm';
    }
    if (comSelect) {
      comSelect.style.backgroundColor = '';
    }
    if (wiredStatus) {
      wiredStatus.textContent = 'Disconnected';
      wiredStatus.style.background = '#e5e7eb';
      wiredStatus.style.color = '#6b7280';
    }
  }
  log(`‚úì Disconnected from device - Serial port released for Arduino IDE`, 'info');
  scanDevices();
}

// ----- Track Names -----
let currentOffset = 0;

function updateOffsetUI() {
  const start = currentOffset + 1;
  const end = currentOffset + 8;
  const offDisplay = $('#offsetDisplay');
  const offRange = $('#offsetRange');
  if (offDisplay) offDisplay.textContent = String(currentOffset);
  if (offRange) offRange.textContent = `${start}-${end}`;
}

function buildTrackGrid() {
  const host = $('#tracks');
  host.innerHTML = '';
  // Show 8 fields per connected device, default to 8 if none connected
  let numDevices = connectedDevices && connectedDevices.size > 0 ? connectedDevices.size : 1;
  let totalTracks = Math.min(numDevices * 8, 32);
  for (let globalIdx = 0; globalIdx < totalTracks; globalIdx++) {
    // Insert visual separators between groups of 8 (1-8 | 9-16 | 17-24 | 25-32)
    if (globalIdx > 0 && globalIdx % 8 === 0) {
      const sep = document.createElement('div');
      sep.className = 'track-sep';
      host.appendChild(sep);
    }
    const row = document.createElement('div');
    row.className = 'trackrow';
    const label = document.createElement('label');
    label.textContent = `Track ${globalIdx + 1}`;
    const input = document.createElement('input');
    input.className = 'input';
    input.id = 'tname' + globalIdx;
    input.name = `track-${globalIdx}`;
    input.value = String(globalIdx + 1);
    input.placeholder = `${globalIdx + 1}`;
    input.oninput = () => saveLocalTrackNames();
    row.appendChild(label);
    row.appendChild(input);
    host.appendChild(row);
  }
}

// ----- Local persistence for Track Names -----
function saveLocalTrackNames() {
  const names = [];
  // Save up to 32 tracks
  for (let i = 0; i < 32; i++) {
    const el = document.getElementById('tname' + i);
    names.push(el ? el.value : '');
  }
  try { localStorage.setItem('tds8_tracknames', JSON.stringify(names)); } catch {}
}

function loadLocalTrackNames() {
  try {
    const raw = localStorage.getItem('tds8_tracknames');
    if (!raw) return false;
    const names = JSON.parse(raw);
    if (!Array.isArray(names)) return false;
    
    // Check if localStorage contains placeholder text or just numbers and clear it
    const hasPlaceholders = names.some(name => {
      if (!name) return false;
      // Match "Track 1", "Track 2", etc. OR just numbers "1", "2", "9", "10", etc.
      return /^Track \d+$/i.test(name) || /^\d+$/.test(name);
    });
    if (hasPlaceholders) {
      console.log('‚ö†Ô∏è Clearing localStorage with placeholder/number text');
      localStorage.removeItem('tds8_tracknames');
      return false;
    }
    
    // Load up to 32 tracks (or however many are in storage)
    for (let i = 0; i < Math.min(32, names.length); i++) {
      const el = document.getElementById('tname' + i);
      if (el && names[i]) {  // Only set if there's a non-empty value
        el.value = names[i];
      }
    }
    log('‚úì Loaded track names from localStorage', 'info');
    return true;
  } catch { return false; }
}

function resetTracks() {
  const numDevices = Math.max(1, connectedDevices.size);
  const totalTracks = Math.min(numDevices * 8, 32);
  
  // Clear all track inputs
  for (let i = 0; i < totalTracks; i++) {
    const inputElement = document.getElementById('tname' + i);
    if (inputElement) {
      inputElement.value = String(i + 1);  // Set to numeric default
    }
  }
  
  // Clear localStorage
  try { localStorage.removeItem('tds8_tracknames'); } catch {}
  
  log(`‚úì Cleared all track names`, 'info');
};

async function saveTracksToBridge() {
  log('üíæ Saving track names to bridge...', 'info');
  const names = [];
  for (let i = 0; i < 32; i++) {
    const el = document.getElementById('tname' + i);
    names.push(el ? el.value : '');
  }

  try {
    const res = await fetch('/api/tracknames', {
      method: 'POST',
      headers: {'Content-Type': 'application/json'},
      body: JSON.stringify({ names })
    });
    const data = await res.json();
    if (data.ok) {
      log('‚úì Track names saved to bridge successfully', 'out');
    } else {
      log(`‚úó Failed to save track names: ${data.error || 'Unknown error'}`, 'err');
    }
  } catch (err) {
    log(`‚úó Error saving track names: ${err.message}`, 'err');
  }
}

// All button handlers moved to DOMContentLoaded

async function refreshFromAbleton() {
  if (!currentDevice) {
    log('‚úó Please connect to TDS-8 device first', 'err');
    log('Click "Connect" button on a device in the TDS-8 Devices section above', 'info');
    return;
  }
  log(`üîÑ Requesting track refresh from Ableton...`, 'info');
  try {
    const res = await fetch('/api/osc-send', {
      method: 'POST',
      headers: {'Content-Type': 'application/json'},
      body: JSON.stringify({
        address: '/reannounce',
        args: []
      })
    });
    if (res.ok) {
      log(`‚úì Sent OSC command: /reannounce`, 'out');
    } else {
      log(`‚úó Failed to send /reannounce`, 'err');
    }
  } catch (err) {
    log(`‚úó Error: ${err.message}`, 'err');
  }
  setTimeout(async () => {
    await loadStoredTrackNames();
  }, 400);
}

async function testOSC() {
  log(`üß™ Testing OSC connection to M4L...`, 'info');
  
  try {
    const res = await fetch('/api/osc-test', {
      method: 'POST'
    });
    
    const data = await res.json();
    if (data.ok) {
      log(`‚úì ${data.message}`, 'out');
      log(`Check bridge console for "üì§ OSC ‚Üí M4L" message`, 'info');
      log(`If M4L responds, you'll see "‚úì Received /hi from M4L"`, 'info');
    } else {
      log(`‚úó ${data.error}`, 'err');
    }
  } catch (err) {
    log(`‚úó Error: ${err.message}`, 'err');
  }
};

// Send track names for a specific device based on its device ID
async function sendTrackNamesForDevice(deviceId) {
  const startTrack = deviceId * 8;
  const endTrack = startTrack + 8;
  
  let count = 0;
  for (let i = startTrack; i < endTrack; i++) {
    const inputElement = document.getElementById('tname' + i);
    const name = inputElement ? inputElement.value.trim() : '';
    
    if (name) {
      const localIndex = i - startTrack;
      const payload = { index: localIndex, name, actualTrack: i };
      console.log(`[AUTO-SEND] Track ${i} to Device ${deviceId}, local index ${localIndex}: "${name}"`);
      await fetch('/api/trackname', {
        method: 'POST',
        headers: {'Content-Type': 'application/json'},
        body: JSON.stringify(payload)
      });
      count++;
      await new Promise(r => setTimeout(r, 20));
    }
  }
  
  if (count > 0) {
    log(`‚úì Sent ${count} track names to Device ${deviceId} (Tracks ${startTrack + 1}-${endTrack})`, 'out');
  }
}

async function sendAllTracks() {
  console.log('[DEBUG] sendAllTracks called');
  console.log('[DEBUG] currentDevice:', currentDevice);
  console.log('[DEBUG] connectedDevices.size:', connectedDevices.size);
  console.log('[DEBUG] connectedDevices:', Array.from(connectedDevices.entries()));
  
  // Check if any device is connected
  if (!currentDevice && connectedDevices.size === 0) {
    log('‚úó Please connect to a TDS-8 device first', 'err');
    log('Click "Connect" button on a device in the TDS-8 Devices section above', 'info');
    return;
  }

  log('üì§ Sending track names to connected devices...', 'info');
  
  const trackToDevice = new Map();
  connectedDevices.forEach((deviceInfo, path) => {
    console.log('[DEBUG] Processing device:', path, deviceInfo);
    const deviceId = deviceInfo.deviceId;
    const startTrack = deviceId * 8;
    const endTrack = startTrack + 8;
    console.log(`[DEBUG] Device ${deviceId}: tracks ${startTrack}-${endTrack-1}`);
    for (let t = startTrack; t < endTrack; t++) {
      trackToDevice.set(t, { deviceId, localIndex: t - startTrack });
    }
  });

  // Fallback for single-device mode when map hasn't been populated yet
  if (trackToDevice.size === 0 && currentDevice) {
    console.log('[DEBUG] Fallback: assuming single device with Device ID 0');
    for (let t = 0; t < 8; t++) {
      trackToDevice.set(t, { deviceId: 0, localIndex: t });
    }
  }
  
  console.log('[DEBUG] trackToDevice map:', Array.from(trackToDevice.entries()));
  
  let count = 0;
  for (let i = 0; i < 32; i++) {
    const inputElement = document.getElementById('tname' + i);
    const name = inputElement ? inputElement.value.trim() : '';
    if (name) {
      console.log(`[DEBUG] Track ${i} has name: "${name}", has mapping: ${trackToDevice.has(i)}`);
    }
    if (name && trackToDevice.has(i)) {
      const { deviceId, localIndex } = trackToDevice.get(i);
      const payload = { index: localIndex, name, actualTrack: i };
      console.log(`[DEBUG] Sending track ${i}:`, payload);
      try {
        const res = await fetch('/api/trackname', {
          method: 'POST',
          headers: {'Content-Type': 'application/json'},
          body: JSON.stringify(payload)
        });
        if (!res.ok) {
          const error = await res.json();
          log(`‚úó Failed to send track ${i}: ${error.error || 'Unknown error'}`, 'err');
        } else {
          count++;
          console.log(`[DEBUG] Successfully sent track ${i}`);
        }
      } catch (err) {
        log(`‚úó Error sending track ${i}: ${err.message}`, 'err');
        console.error('[DEBUG] Error:', err);
      }
      await new Promise(r => setTimeout(r, 20));
    }
  }
  saveLocalTrackNames();
  if (count > 0) {
    log(`‚úì Updated ${count} track names to connected devices`, 'out');
  } else {
    log('‚ö†Ô∏è No track names were sent (fields may be empty or no devices connected)', 'info');
  }
}

// ----- Modals -----

// Shared WiFi scan function
async function scanWiFiNetworks() {
  log('üì° Scanning for WiFi networks...', 'info');
  try {
    const res = await fetch('/api/wifi-scan');
    const data = await res.json();
    if (data.ok && data.ssids) {
      scannedNetworks = data.ssids;
      displayNetworkList();
      // Also populate top bar dropdown
      const wifiSelect = $('#wifiNetworkSelect');
      if (wifiSelect) {
        wifiSelect.innerHTML = '<option value="">Select WiFi network...</option>';
        data.ssids.forEach(ssid => {
          const option = document.createElement('option');
          option.value = ssid;
          option.textContent = ssid;
          wifiSelect.appendChild(option);
        });
      }
      log(`‚úì Found ${data.ssids.length} networks`, 'out');
    } else {
      log(`‚úó Scan failed: ${data.error || 'Unknown error'}`, 'err');
    }
  } catch (err) {
    log(`‚úó Scan error: ${err.message}`, 'err');
  }
}

// All WiFi and Firmware button handlers moved to DOMContentLoaded

// ----- Wi-Fi -----
let scannedNetworks = [];

function displayNetworkList() {
  const container = $('#networkList');
  container.innerHTML = '';
  
  // Show saved networks first
  if (savedWifiNetworks.length > 0) {
    const savedHeader = document.createElement('div');
    savedHeader.style.padding = '12px 16px 8px';
    savedHeader.style.fontSize = '11px';
    savedHeader.style.fontWeight = '600';
    savedHeader.style.color = 'var(--muted)';
    savedHeader.style.textTransform = 'uppercase';
    savedHeader.style.letterSpacing = '0.5px';
    savedHeader.textContent = 'Saved Networks';
    container.appendChild(savedHeader);
    
    savedWifiNetworks.forEach((network, idx) => {
      const item = document.createElement('div');
      item.className = 'network-item saved';
      item.innerHTML = `
        <div class="name">üì° ${network.ssid}</div>
        <div class="icon">‚úì</div>
      `;
      item.onclick = () => connectToNetwork(network.ssid, network.password);
      container.appendChild(item);
    });
  }
  
  // Show scanned networks
  if (scannedNetworks.length > 0) {
    const scannedHeader = document.createElement('div');
    scannedHeader.style.padding = '12px 16px 8px';
    scannedHeader.style.fontSize = '11px';
    scannedHeader.style.fontWeight = '600';
    scannedHeader.style.color = 'var(--muted)';
    scannedHeader.style.textTransform = 'uppercase';
    scannedHeader.style.letterSpacing = '0.5px';
    scannedHeader.textContent = 'Available Networks';
    container.appendChild(scannedHeader);
    
    scannedNetworks.forEach(ssid => {
      // Skip if already saved
      if (savedWifiNetworks.some(n => n.ssid === ssid)) return;
      
      const item = document.createElement('div');
      item.className = 'network-item';
      item.innerHTML = `
        <div class="name">üì° ${ssid}</div>
        <div class="icon">‚Üí</div>
      `;
      item.onclick = () => {
        // Pre-fill the add network modal with this SSID
        $('#ssidInput').value = ssid;
        $('#modalAddNetwork').style.display = 'block';
      };
      container.appendChild(item);
    });
  }
  
  // Add placeholder if no networks at all
  if (savedWifiNetworks.length === 0 && scannedNetworks.length === 0) {
    const placeholder = document.createElement('div');
    placeholder.style.padding = '20px';
    placeholder.style.textAlign = 'center';
    placeholder.style.color = 'var(--muted)';
    placeholder.style.fontSize = '12px';
    placeholder.textContent = 'No networks found. Click "Scan for Networks" or "Add Network".';
    container.appendChild(placeholder);
  }
}

async function connectToNetwork(ssid, password) {
  // Step 1: Send WiFi credentials
  log(`üì° Step 1/3: Saving WiFi credentials for "${ssid}"...`, 'info');
  const r1 = await fetch('/api/wifi-join', {
    method: 'POST',
    headers: {'Content-Type': 'application/json'},
    body: JSON.stringify({ ssid, password })
  });
  
  const j1 = await r1.json();
  if (!j1.ok) {
    log(`‚úó Failed to save WiFi credentials: ${j1.error}`, 'err');
    return;
  }
  
  log(`‚úì WiFi credentials saved`, 'out');
  
  // Step 2: Disable wired-only mode
  log(`üì° Step 2/3: Enabling WiFi mode...`, 'info');
  await new Promise(r => setTimeout(r, 500)); // Small delay
  
  const r2 = await fetch('/api/comm-mode', {
    method: 'POST',
    headers: {'Content-Type': 'application/json'},
    body: JSON.stringify({ mode: 'wifi' })
  });
  
  const j2 = await r2.json();
  if (!j2.ok) {
    log(`‚úó Failed to enable WiFi mode: ${j2.error}`, 'err');
    return;
  }
  
  log(`‚úì WiFi mode enabled`, 'out');
  
  // Step 3: Reboot device
  log(`üì° Step 3/3: Rebooting device to connect to WiFi...`, 'info');
  await new Promise(r => setTimeout(r, 1000)); // Wait for settings to save
  
  try {
    await fetch('/api/send', {
      method: 'POST',
      headers: {'Content-Type': 'application/json'},
      body: JSON.stringify({ cmd: 'REBOOT' })
    });
  } catch (e) {
    // Device may disconnect before responding, that's OK
  }
  
  log(`‚úì Device rebooting...`, 'out');
  log(`‚ö†Ô∏è Device will disconnect from USB and connect to "${ssid}"`, 'info');
  log(`‚è≥ Wait 10-15 seconds for device to connect to WiFi`, 'info');
  log(`üí° Check your router to find the device's IP address`, 'info');
  
  $('#modalWifi').style.display = 'none';
}

async function saveNetwork() {
  const ssid = $('#ssidInput').value.trim();
  const password = $('#pwd').value;
  
  if (!ssid) {
    log('‚úó Please enter a network name', 'err');
    return;
  }
  
  // Check if already saved
  const existing = savedWifiNetworks.findIndex(n => n.ssid === ssid);
  if (existing >= 0) {
    // Update password
    savedWifiNetworks[existing].password = password;
  } else {
    // Add new
    savedWifiNetworks.push({ ssid, password });
  }
  
  saveSavedNetworks();
  log(`‚úì Saved network: ${ssid}`, 'out');
  
  // Connect to it
  await connectToNetwork(ssid, password);
  
  // Clear inputs and close
  $('#ssidInput').value = '';
  $('#pwd').value = '';
  $('#modalAddNetwork').style.display = 'none';
  
  displayNetworkList();
};

// ----- Firmware -----
const MANIFEST_URL = 'https://raw.githubusercontent.com/m1llipede/tds8/main/manifest.json';

async function checkFirmware() {
  if (!currentDevice) {
    const status = $('#firmwareStatus');
    status.innerHTML = `
      <div style="font-size:48px;margin-bottom:12px">‚ö†Ô∏è</div>
      <h3 style="margin:0 0 8px;color:var(--text);font-size:15px">No Device Connected</h3>
      <p style="color:var(--muted);margin:0;font-size:12px">Please connect a TDS-8 device first</p>
    `;
    log('‚úó Please connect a device before checking for updates', 'err');
    return;
  }
  
  const status = $('#firmwareStatus');
  status.innerHTML = '<div style="font-size:48px;margin-bottom:12px">‚è≥</div><p style="color:var(--muted);font-size:13px">Checking for updates...</p>';
  
  try {
    const url = new URL('/api/ota-check', window.location.origin);
    url.searchParams.set('manifest', MANIFEST_URL);
    
    const res = await fetch(url);
    const j = await res.json();
    
    if (j.ok) {
      const deviceVer = j.deviceVersion || 'Unknown';
      const latestVer = j.manifest.version;
      const isNewer = j.isNewer;
      
      if (isNewer) {
        status.innerHTML = `
          <div style="font-size:48px;margin-bottom:12px">üéâ</div>
          <h3 style="margin:0 0 8px;color:var(--text);font-size:15px">Update Available!</h3>
          <p style="color:var(--muted);margin:0;font-size:12px">Current: ${deviceVer} ‚Üí New: ${latestVer}</p>
        `;
        $('#btnOta').style.display = 'inline-flex';
        log(`Update available: ${latestVer}`, 'info');
      } else {
        status.innerHTML = `
          <div style="font-size:48px;margin-bottom:12px">‚úÖ</div>
          <h3 style="margin:0 0 8px;color:var(--text);font-size:15px">Up to Date</h3>
          <p style="color:var(--muted);margin:0;font-size:12px">Version ${deviceVer}</p>
        `;
        $('#btnOta').style.display = 'none';
        log(`Firmware is up to date (${deviceVer})`, 'info');
      }
    } else {
      status.innerHTML = `
        <div style="font-size:48px;margin-bottom:12px">‚ö†Ô∏è</div>
        <h3 style="margin:0 0 8px;color:var(--text);font-size:15px">Check Failed</h3>
        <p style="color:var(--muted);margin:0;font-size:12px">${j.error}</p>
      `;
      log(`‚úó Update check failed: ${j.error}`, 'err');
    }
  } catch (err) {
    const errorMsg = err.message.includes('404') 
      ? 'Firmware manifest not found. The update file may not exist yet at the GitHub repository.'
      : 'Could not reach update server. Check your internet connection.';
    
    status.innerHTML = `
      <div style="font-size:48px;margin-bottom:12px">‚ö†Ô∏è</div>
      <h3 style="margin:0 0 8px;color:var(--text);font-size:15px">Connection Error</h3>
      <p style="color:var(--muted);margin:0;font-size:12px">${errorMsg}</p>
    `;
    log(`‚úó Network error: ${err.message}`, 'err');
  }
};

async function startOTA() {
  if (!confirm('Start firmware update? Device will switch to Wi-Fi mode and update.')) return;
  
  const status = $('#firmwareStatus');
  status.innerHTML = '<div style="font-size:48px;margin-bottom:12px">‚¨áÔ∏è</div><p style="color:var(--muted);font-size:13px">Starting update...</p>';
  
  const res = await fetch('/api/ota-update', {
    method: 'POST',
    headers: {'Content-Type': 'application/json'},
    body: JSON.stringify({ manifest: MANIFEST_URL })
  });
  
  const j = await res.json();
  if (j.ok) {
    status.innerHTML = '<div style="font-size:48px;margin-bottom:12px">‚úÖ</div><p style="color:#10b981;font-size:13px">Update started! Device will reboot when complete.</p>';
    log('‚úì Firmware update started', 'out');
  } else {
    status.innerHTML = `<div style="font-size:48px;margin-bottom:12px">‚ö†Ô∏è</div><p style="color:#ef4444;font-size:13px">Update failed: ${j.error}</p>`;
    log(`‚úó Update failed: ${j.error}`, 'err');
  }
};

// ----- Commands -----
async function sendCmd(cmd) {
  cmd = (cmd || '').trim();
  if (!cmd) return;
  
  const res = await fetch('/api/send', {
    method: 'POST',
    headers: {'Content-Type': 'application/json'},
    body: JSON.stringify({ cmd })
  });
  
  const j = await res.json();
  if (j.ok) log(`‚Üí ${cmd}`, 'out');
  else log(`‚úó Send error: ${j.error}`, 'err');
}

function sendCommand() {
  sendCmd($('#cmd').value);
  $('#cmd').value = '';
}


// ----- WebSocket -----
(() => {
  const ws = new WebSocket((location.protocol === 'https:' ? 'wss://' : 'ws://') + location.host);
  ws.onmessage = ev => {
    const msg = JSON.parse(ev.data);
    if (msg.type === 'serial-data') {
      const lines = msg.data.split('\n');
      lines.forEach(line => {
        if (line.trim()) log(line, 'info');
      });
    }
    if (msg.type === 'serial-open') {
      log(`‚úì Serial port opened: ${msg.path}`, 'out');
      scanDevices();
      // Check device status after serial opens
      setTimeout(() => checkDeviceStatus(), 1000);
    }
    
    // Handle serial port close (device disconnected)
    if (msg.type === 'serial-close') {
      log(`‚ö†Ô∏è Serial port closed: ${msg.path}`, 'warn');
      connectedDevices.delete(msg.path);
      if (currentDevice === msg.path) {
        currentDevice = null;
        updateConnectionStatus(false);
      }
      scanDevices();
      buildTrackGrid();
    }
    
    // Handle multi-device connection
    if (msg.type === 'multi-device-connected') {
      msg.devices.forEach(d => {
        if (d.ok) {
          connectedDevices.set(d.path, { deviceId: d.deviceId, tracks: `${d.deviceId * 8 + 1}-${(d.deviceId + 1) * 8}` });
        }
      });
      scanDevices();
    }
    if (msg.type === 'serial-error') log(`‚úó Serial error: ${msg.message}`, 'err');
    if (msg.type === 'device-version') {
      log(`Device version: ${msg.version}`, 'info');
      // Store version for display - use path if provided, otherwise currentDevice
      const devicePath = msg.path || currentDevice;
      if (devicePath) {
        deviceVersions.set(devicePath, msg.version);
        scanDevices(); // Refresh device list to show version
      }
    }
    
    // Handle device mode update (on startup)
    if (msg.type === 'device-mode') {
      updateConnectionBanner(msg.mode, msg.ip);
      
      const wifiStatus = $('#wifiStatus');
      const wifiSelect = $('#wifiNetworkSelect');
      const wiredStatus = $('#wiredStatus');
      const wiredBtn = $('#btnWiredConnect');
      const comSelect = $('#comPortSelect');
      
      if (msg.mode === 'wifi') {
        // Device is in WiFi mode
        if (wifiStatus) {
          wifiStatus.textContent = 'Connected';
          wifiStatus.style.background = '#10b981';
          wifiStatus.style.color = '#fff';
        }
        if (wifiSelect) {
          wifiSelect.style.backgroundColor = '#d1fae5';
        }
        if (wiredStatus) {
          wiredStatus.textContent = 'Disconnected';
          wiredStatus.style.background = '#e5e7eb';
          wiredStatus.style.color = '#6b7280';
        }
        if (wiredBtn) {
          wiredBtn.textContent = 'Connect';
          wiredBtn.className = 'btn primary sm';
        }
        if (comSelect) {
          comSelect.style.backgroundColor = '';
        }
      } else {
        // Device is in Wired mode
        if (wiredStatus) {
          wiredStatus.textContent = 'Connected';
          wiredStatus.style.background = '#10b981';
          wiredStatus.style.color = '#fff';
        }
        if (comSelect) {
          comSelect.style.backgroundColor = '#d1fae5';
        }
        if (wifiStatus) {
          wifiStatus.textContent = 'Disconnected';
          wifiStatus.style.background = '#e5e7eb';
          wifiStatus.style.color = '#6b7280';
        }
        if (wifiSelect) {
          wifiSelect.style.backgroundColor = '';
        }
      }
    }
    
    // OSC messages in Serial Monitor
    if (msg.type === 'osc-sent') {
      log(`Sent: ${msg.address}${msg.argsStr || ''}`, 'out');
    }
    if (msg.type === 'osc-received') {
      const argsStr = msg.args && msg.args.length > 0 
        ? ' [' + msg.args.map(a => a.value).join(', ') + ']' 
        : '';
      log(`Received: ${msg.address}${argsStr}`, 'info');
    }
    
    // Handle device IP update (WiFi connection)
    if (msg.type === 'device-ip') {
      console.log('üì° Received device-ip:', msg);
      const wifiStatus = $('#wifiStatus');
      const wifiSelect = $('#wifiNetworkSelect');
      const wiredStatus = $('#wiredStatus');
      const wiredBtn = $('#btnWiredConnect');
      const comSelect = $('#comPortSelect');
      
      if (msg.connectionType === 'wifi') {
        // Device connected to WiFi
        log(`‚úÖ Device connected to WiFi: ${msg.ip}${msg.ssid ? ' (' + msg.ssid + ')' : ''}`, 'out');
        
        // Update connection banner
        console.log('üì° Updating banner to WiFi:', msg.ip);
        updateConnectionBanner('wifi', msg.ip);
        
        if (wifiStatus) {
          wifiStatus.textContent = 'Connected';
          wifiStatus.style.background = '#10b981';
          wifiStatus.style.color = '#fff';
        }
        if (wifiSelect) {
          wifiSelect.style.backgroundColor = '#d1fae5';
        }
        
        // Clear wired connection UI (USB disconnects when WiFi connects)
        if (wiredStatus) {
          wiredStatus.textContent = 'Disconnected';
          wiredStatus.style.background = '#e5e7eb';
          wiredStatus.style.color = '#6b7280';
        }
        if (wiredBtn) {
          wiredBtn.textContent = 'Connect';
          wiredBtn.className = 'btn primary sm';
        }
        if (comSelect) {
          comSelect.style.backgroundColor = '';
        }
        
        // Update connection status
        updateConnectionStatus(false);
      } else if (msg.connectionType === 'wired') {
        // Device connected via USB
        updateConnectionBanner('wired', msg.ip);
      }
    }
  };
  ws.onerror = () => log('‚úó WebSocket connection error', 'err');
  ws.onclose = () => log('WebSocket disconnected', 'info');
})();

// Helper function to load stored track names
async function loadStoredTrackNames() {
  try {
    const res = await fetch('/api/tracknames');
    const j = await res.json();
    if (j && j.ok && Array.isArray(j.names)) {
      for (let i = 0; i < 8; i++) {
        const input = document.getElementById('tname' + i);
        if (input) input.value = j.names[i] || '';
      }
      log('‚úì Loaded stored track names', 'info');
    } else {
      log(`‚úó Failed to load track names: ${j && j.error ? j.error : 'Unknown error'}`, 'err');
    }
  } catch (e) {
    log(`‚úó Failed to load track names: ${e.message}`, 'err');
  }
}

// Check device status on load
async function checkDeviceStatus() {
  try {
    const res = await fetch('/api/device-status');
    const data = await res.json();
    if (data.ok && data.connectionType !== 'none') {
      updateConnectionBanner(data.connectionType, data.ip);
      
      const wifiStatus = $('#wifiStatus');
      const wifiSelect = $('#wifiNetworkSelect');
      const wiredStatus = $('#wiredStatus');
      const wiredBtn = $('#btnWiredConnect');
      const comSelect = $('#comPortSelect');
      
      if (data.connectionType === 'wifi') {
        // Update WiFi UI
        if (wifiStatus) {
          wifiStatus.textContent = 'Connected';
          wifiStatus.style.background = '#10b981';
          wifiStatus.style.color = '#fff';
        }
        if (wifiSelect) {
          wifiSelect.style.backgroundColor = '#d1fae5';
        }
        // Clear wired UI
        if (wiredStatus) {
          wiredStatus.textContent = 'Disconnected';
          wiredStatus.style.background = '#e5e7eb';
          wiredStatus.style.color = '#6b7280';
        }
        if (wiredBtn) {
          wiredBtn.textContent = 'Connect';
          wiredBtn.className = 'btn primary sm';
        }
        if (comSelect) {
          comSelect.style.backgroundColor = '';
        }
      } else if (data.connectionType === 'wired') {
        // Update Wired UI
        if (wiredStatus) {
          wiredStatus.textContent = 'Connected';
          wiredStatus.style.background = '#10b981';
          wiredStatus.style.color = '#fff';
        }
        if (comSelect) {
          comSelect.style.backgroundColor = '#d1fae5';
        }
        // Clear WiFi UI
        if (wifiStatus) {
          wifiStatus.textContent = 'Disconnected';
          wifiStatus.style.background = '#e5e7eb';
          wifiStatus.style.color = '#6b7280';
        }
        if (wifiSelect) {
          wifiSelect.style.backgroundColor = '';
        }
      }
      
      log(`Device already connected: ${data.connectionType} (${data.ip})`, 'info');
    }
  } catch (e) {
    console.error('Failed to check device status:', e);
  }
}

// ----- Init -----
window.addEventListener('DOMContentLoaded', () => {
  log('TDS-8 Control ready', 'info');
  
  buildTrackGrid();
  loadLocalTrackNames();
  scanDevices(); // Scan for devices on page load
  setInterval(scanDevices, 5000);
  checkDeviceStatus();

  // Attach all button event listeners safely (inside DOMContentLoaded)
  const refreshBtn = document.getElementById('btnRefreshDevices');
  if (refreshBtn) {
    refreshBtn.onclick = async () => {
      log('üîÑ Manually refreshing device list...', 'info');
      await scanDevices();
      log('‚úì Device list refreshed', 'out');
    };
  }

  const btnRefresh = document.getElementById('btnRefresh');
  if (btnRefresh) btnRefresh.onclick = refreshFromAbleton;

  const btnSendAll = document.getElementById('btnSendAll');
  if (btnSendAll) btnSendAll.onclick = sendAllTracks;

  const btnResetTracks = document.getElementById('btnResetTracks');
  if (btnResetTracks) {
    btnResetTracks.textContent = 'Reset Track Names';
    btnResetTracks.onclick = resetTracks;
  }

  const btnSaveTracks = document.getElementById('btnSaveTracks');
  if (btnSaveTracks) {
    btnSaveTracks.onclick = saveTracksToBridge;
  }

  // WiFi buttons
  const btnScanNetworks = document.getElementById('btnScanNetworks');
  if (btnScanNetworks) btnScanNetworks.onclick = scanWiFiNetworks;

  const btnWifiScanQuick = document.getElementById('btnWifiScanQuick');
  if (btnWifiScanQuick) btnWifiScanQuick.onclick = scanWiFiNetworks;

  const btnAddNetwork = document.getElementById('btnAddNetwork');
  if (btnAddNetwork) btnAddNetwork.onclick = () => $('#modalAddNetwork').style.display = 'block';

  const btnCancelAdd = document.getElementById('btnCancelAdd');
  if (btnCancelAdd) btnCancelAdd.onclick = () => $('#modalAddNetwork').style.display = 'none';

  const btnSaveNetwork = document.getElementById('btnSaveNetwork');
  if (btnSaveNetwork) btnSaveNetwork.onclick = saveNetwork;

  const btnCloseWifi = document.getElementById('btnCloseWifi');
  if (btnCloseWifi) btnCloseWifi.onclick = () => $('#modalWifi').style.display = 'none';

  // Firmware buttons
  const btnFirmwareTop = document.getElementById('btnFirmwareTop');
  if (btnFirmwareTop) {
    btnFirmwareTop.onclick = () => {
      $('#modalFirmware').style.display = 'block';
      if (currentDevice) {
        const btnCheck = $('#btnCheck');
        if (btnCheck) btnCheck.click();
      }
    };
  }

  const btnCloseFirmware = document.getElementById('btnCloseFirmware');
  if (btnCloseFirmware) btnCloseFirmware.onclick = () => $('#modalFirmware').style.display = 'none';

  const btnCheck = document.getElementById('btnCheck');
  if (btnCheck) btnCheck.onclick = checkFirmware;

  const btnOta = document.getElementById('btnOta');
  if (btnOta) btnOta.onclick = startOTA;

  // Command input
  const btnSend = document.getElementById('btnSend');
  if (btnSend) btnSend.onclick = sendCommand;

  const cmdInput = document.getElementById('cmd');
  if (cmdInput) {
    cmdInput.onkeypress = (e) => {
      if (e.key === 'Enter') sendCommand();
    };
  }

  const btnReadTracks = document.getElementById('btnReadTracks');
  if (btnReadTracks) {
    btnReadTracks.onclick = async () => {
      log('üìñ Reading stored track names...', 'info');
      try {
        const res = await fetch('/api/tracknames');
        const data = await res.json();
        if (data.ok && data.names) {
          for (let i = 0; i < 8 && i < data.names.length; i++) {
            const inputElement = document.getElementById('tname' + i);
            if (inputElement) {
              inputElement.value = data.names[i] || '';
            }
          }
          log(`‚úì Loaded ${data.names.length} track names from bridge`, 'out');
        } else {
          log('‚úó Failed to read track names', 'err');
        }
      } catch (err) {
        log(`‚úó Error: ${err.message}`, 'err');
      }
    };
  }

  const wiredConnectBtn = document.getElementById('btnWiredConnect');
  if (wiredConnectBtn) {
    wiredConnectBtn.onclick = async () => {
      if (currentDevice) {
        await fetch('/api/disconnect', { method: 'POST' });
        disconnect(currentDevice);
        return;
      }
      const comSelect = document.getElementById('comPortSelect');
      const path = comSelect ? comSelect.value : '';
      if (!path) { 
        log('‚úó Select a COM port from the dropdown', 'err'); 
        return; 
      }
      try {
        const portName = path.split(/[/\\]/).pop();
        await connect(path, portName, null);
        wiredConnectBtn.textContent = 'Disconnect';
        wiredConnectBtn.className = 'btn ghost sm';
        comSelect.style.backgroundColor = '#d1fae5';
        const wiredStatus = $('#wiredStatus');
        if (wiredStatus) {
          wiredStatus.textContent = 'Connected';
          wiredStatus.style.background = '#10b981';
          wiredStatus.style.color = '#fff';
        }
      } catch (e) {
        log(`‚úó Connect failed: ${e.message}`, 'err');
      }
    };
  }

  const wifiConnectBtn = document.getElementById('btnWifiConnect');
  if (wifiConnectBtn) {
    wifiConnectBtn.onclick = async () => {
      if (!currentDevice) {
        log('‚úó Please connect to TDS-8 device first (wired connection required to configure WiFi)', 'err');
        return;
      }
      const wifiSelect = document.getElementById('wifiNetworkSelect');
      const ssid = wifiSelect ? wifiSelect.value : '';
      if (!ssid) {
        log('‚úó Select a WiFi network from the dropdown', 'err');
        return;
      }
      const savedNetwork = savedWifiNetworks.find(n => n.ssid === ssid);
      let password;
      if (savedNetwork) {
        password = savedNetwork.password;
        log(`üì° Using saved password for "${ssid}"`, 'info');
      } else {
        password = prompt(`Enter password for WiFi network "${ssid}":\n\n(Leave blank if no password)`);
        if (password === null) return;
      }
      log(`üì° Configuring TDS-8 to connect to "${ssid}"...`, 'info');
      log('‚ö†Ô∏è Device will disconnect from USB and switch to WiFi mode', 'info');
      await connectToNetwork(ssid, password);
    };
  }

  // Auto-scan WiFi networks after a short delay
  setTimeout(async () => {
    try {
      const res = await fetch('/api/wifi-scan');
      const data = await res.json();
      if (data.ok && data.ssids) {
        scannedNetworks = data.ssids;
        const wifiSelect = $('#wifiNetworkSelect');
        if (wifiSelect) {
          wifiSelect.innerHTML = '<option value="">Select WiFi network...</option>';
          data.ssids.forEach(ssid => {
            const option = document.createElement('option');
            option.value = ssid;
            option.textContent = ssid;
            wifiSelect.appendChild(option);
          });
        }
        console.log(`‚úì Auto-scan found ${data.ssids.length} WiFi networks`);
      } else {
        console.log('WiFi scan returned no networks:', data);
      }
    } catch (err) {
      console.log('WiFi scan on startup failed:', err);
    }
  }, 2000);
});
</script>
</body>
</html>