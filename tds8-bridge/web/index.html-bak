<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>TDS-8 Control</title>
<link rel="icon" type="image/svg+xml" href="/favicon.svg">
<style>
:root{--brand:#ff8800;--brand2:#8a2be2;--text:#222;--muted:#666;--card:#fff;--bg:#f6f7fb;--hover:#f0f1f5}
*{box-sizing:border-box}
body{margin:0;background:var(--bg);font:14px/1.3 system-ui,Segoe UI,Roboto;color:var(--text);overflow:hidden}
.wrap{max-width:100%;height:100vh;display:flex;flex-direction:column;padding:12px}
.main-grid{display:grid;grid-template-columns:1fr 380px;gap:12px;flex:1;min-height:0}
.left-col{display:flex;flex-direction:column;gap:12px;overflow-y:auto}
.right-col{display:flex;flex-direction:column;min-height:0}
.card{background:var(--card);border-radius:10px;box-shadow:0 4px 12px rgba(0,0,0,.06);overflow:hidden}
.card.flex{display:flex;flex-direction:column;flex:1;min-height:0}
.hdr{background:linear-gradient(135deg,var(--brand),var(--brand2));padding:12px 16px;color:#fff}
.hdr h1{margin:0;font-size:16px;font-weight:600}
.body{padding:16px}
.body.flex{flex:1;min-height:0;display:flex;flex-direction:column}
.grid{display:grid;grid-template-columns:1fr 1fr;gap:10px}
.grid3{display:grid;grid-template-columns:1fr 1fr;gap:10px}
label{display:block;color:var(--text);font-size:13px;font-weight:500;margin-bottom:6px}
.input{padding:8px 10px;border:2px solid #e3e6ef;border-radius:8px;background:#fff;width:100%;font-size:13px;transition:all .2s}
.input:focus{outline:none;border-color:var(--brand);box-shadow:0 0 0 2px rgba(255,136,0,.1)}
select.input{cursor:pointer}
.btn{appearance:none;border:0;border-radius:8px;padding:8px 14px;cursor:pointer;font-size:13px;font-weight:500;transition:all .2s;display:inline-flex;align-items:center;justify-content:center;gap:6px}
.btn:hover{transform:translateY(-1px);box-shadow:0 3px 8px rgba(0,0,0,.12)}
.btn:active{transform:translateY(0)}
.btn.primary{background:var(--brand);color:#fff}
.btn.primary:hover{background:#ff9920}
.btn.secondary{background:var(--brand2);color:#fff}
.btn.secondary:hover{background:#9b3bf3}
.btn.ghost{background:#fff;border:2px solid #e3e6ef;color:var(--text)}
.btn.ghost:hover{background:var(--hover);border-color:#d0d3df}
.btn.ghost.active{background:var(--brand);color:#fff;border-color:var(--brand)}
.btn.sm{padding:6px 10px;font-size:12px}
.btn-group{display:flex;gap:8px;flex-wrap:wrap}
.device-list{display:flex;flex-direction:column;gap:6px}
.device-item{background:#f3f4f6;border:2px solid #d1d5db;border-radius:8px;padding:10px 12px;display:flex;justify-content:space-between;align-items:center;transition:all .2s;opacity:0.6}
.device-item:hover{border-color:var(--brand);background:#fff;opacity:1}
.device-item.connected{border-color:var(--brand);background:#fff8f0;opacity:1}
.device-name{font-weight:600;font-size:14px;color:var(--text)}
.device-status{font-size:11px;color:#10b981;margin-top:2px}
.trackgrid{display:grid;grid-template-columns:repeat(2,1fr);gap:4px;max-height:650px;overflow-y:scroll;padding-right:8px}
.trackrow{display:flex;gap:6px;align-items:center}
.trackrow label{margin:0;min-width:60px;font-weight:600;font-size:12px;color:var(--text)}
.trackrow .input{padding:5px 8px;font-size:12px}
.track-sep{grid-column:1 / -1;height:6px;border-radius:6px;margin:6px 0;background:linear-gradient(90deg,#ff8800 0%, #8a2be2 100%);opacity:0.3}
.serial-card{max-height:calc(100vh - 140px);display:flex;flex-direction:column}
.serial-card .body.flex{flex:1;min-height:0;display:flex;flex-direction:column}
.icon-card{text-align:center;padding:20px 16px;cursor:pointer;transition:all .2s;border-radius:8px;border:2px solid transparent}
.icon-card:hover{background:var(--hover);border-color:#e3e6ef;transform:translateY(-1px)}
.icon-card .icon{font-size:36px;margin-bottom:8px}
.icon-card h3{margin:0 0 4px;font-size:14px;font-weight:600}
.icon-card p{margin:0;font-size:11px;color:var(--muted);line-height:1.3}
.log{font-family:ui-monospace,Menlo,Consolas,monospace;background:#fafbff;color:var(--text);border:2px solid #e3e6ef;border-radius:8px;padding:12px;overflow-y:scroll;font-size:11px;line-height:1.5;flex:1;min-height:200px;max-height:100%}
.log::-webkit-scrollbar{width:12px}
.log::-webkit-scrollbar-track{background:#e3e6ef;border-radius:4px}
.log::-webkit-scrollbar-thumb{background:#999;border-radius:4px}
.log::-webkit-scrollbar-thumb:hover{background:#666}
.log-line{margin:1px 0}
.log-line.out{color:#10b981}
.log-line.err{color:#ef4444}
.helpbox{margin-top:10px;padding:10px 12px;border:2px solid #e3e6ef;border-radius:8px;background:#fafbff;font-size:11px;color:#444}
.helpbox code{background:#fff;border:1px solid #e3e6ef;border-radius:4px;padding:0 4px}
.divider{height:1px;background:#e3e6ef;margin:12px 0}
.notice{background:#fef3c7;border:2px solid #fbbf24;border-radius:8px;padding:10px 12px;font-size:12px;color:#92400e;margin-bottom:12px}
.network-item{display:flex;justify-content:space-between;align-items:center;padding:12px;background:#fafbff;border-bottom:1px solid #e3e6ef;transition:all .2s;cursor:pointer}
.network-item:hover{background:#fff}
.network-item:last-child{border-bottom:none}
.network-item .name{font-weight:500;font-size:14px;color:var(--text)}
.network-item .icon{font-size:20px;color:var(--muted)}
.network-item.saved .name{color:#e91e63}
.network-item.saved .icon{color:#e91e63}
.footer-info{text-align:center;padding:16px;background:#fafbff;border-top:1px solid #e3e6ef;font-size:11px;color:var(--muted)}
.footer-info .company{font-weight:600;color:var(--text);margin-bottom:4px}
.footer-info .serial{font-family:ui-monospace,monospace}
</style>
</head>
<body>
  <div class="wrap" style="display:block;" id="mainApp">
    <!-- Connection Status Banner (hidden; controls moved below Serial Monitor) -->
    <div id="connectionBanner" style="display:none"></div>
    
    <div class="main-grid">
      <!-- Left Column -->
      <div class="left-col">
        
        <!-- Devices -->
        <div class="card">
          <div class="hdr" style="display:flex;justify-content:space-between;align-items:center">
            <h1>üéõÔ∏è TDS-8 Devices</h1>
            <div style="display:flex;gap:8px;align-items:center">
              <button id="btnFirmwareTop" class="btn secondary sm" title="Check for Firmware Updates" style="background:rgba(255,255,255,0.2);color:#fff;border:1px solid rgba(255,255,255,0.3);padding:4px 10px;font-size:11px">‚¨áÔ∏è Firmware</button>
              <button id="btnRefreshDevices" class="btn ghost sm" style="background:rgba(255,255,255,0.2);color:#fff;border:1px solid rgba(255,255,255,0.3);padding:4px 10px;font-size:11px">üîÑ Refresh</button>
            </div>
          </div>
          <div class="body">
            <div id="deviceList" class="device-list">
              <div style="text-align:center;padding:12px;color:var(--muted);font-size:12px">
                Scanning for devices...
              </div>
            </div>
            
          </div>
        </div>

        <!-- Track Names -->
        <div class="card">
          <div class="hdr" style="display:flex;justify-content:space-between;align-items:center"><h1>üéµ Track Names</h1></div>
          <div class="body" style="display:flex;flex-direction:column;min-height:0;max-height:500px;overflow-y:auto;">
            <div class="btn-group" id="trackBtnGroup" style="margin-bottom:12px"></div>
            <!-- Offset Controls (hidden for now) -->
            <div style="display:none"></div>
            
            <div class="trackgrid" id="tracks" style="overflow-y:auto;max-height:320px;"></div>
            <div class="divider"></div>
            <div class="btn-group" style="margin-bottom:8px">
              <button id="btnRefresh" class="btn primary">üîÑ Refresh from Ableton</button>
              <button id="btnSendAll" class="btn ghost sm">Update All Tracks</button>
              <button id="btnResetTracks" class="btn ghost sm">Clear All Tracks</button>
              <button id="btnSaveTracks" class="btn secondary sm">Save Current Tracks</button>
              <button id="btnReadTracks" class="btn secondary sm">Load Stored Tracks</button>
            </div>
          </div>
        </div>

      </div>

      <!-- Right Column - Serial Monitor -->
      <div class="right-col">
        <div class="card flex serial-card">
          <div class="hdr">
            <h1>üìü Serial Monitor</h1>
            <label style="display:flex;align-items:center;gap:6px;font-size:12px;margin-left:auto;cursor:pointer">
              <input type="checkbox" id="autoScroll" checked style="cursor:pointer"/>
              Auto-scroll
            </label>
            <span style="font-size:11px;color:#fff;margin-left:12px;">v103025-7</span>
          </div>
          <div class="body flex">
            <div id="log" class="log"></div>
            <div style="margin-top:10px;display:flex;gap:8px;align-items:center;flex-wrap:wrap">
              <input id="cmd" class="input" placeholder="Send command... (defaults to ALL devices)" style="flex:1;font-size:12px;padding:6px 8px" autocomplete="off" autocapitalize="off" spellcheck="false" data-lpignore="true" inputmode="text" name="tds8_command"/>
              <button id="btnSend" class="btn ghost sm">Send</button>
              <div class="btn-group" style="gap:6px">
                <button id="qaRebootAll" class="btn sm ghost" title="Reboot all devices">Reboot All</button>
                <button id="qaVersionAll" class="btn sm ghost" title="Request version from all devices">Version All</button>
              </div>
            </div>
            <!-- Compact Connection Controls (moved here) -->
            <div style="margin-top:12px">
              <div style="font-size:12px;font-weight:600;color:#374151;text-align:center;margin-bottom:6px">TDS-8 Connection</div>
              <div style="display:flex;gap:10px;align-items:center;justify-content:center">
                <select id="connectionTypeSelect" class="input" style="padding:6px 10px;width:140px">
                  <option value="wired">Wired (USB)</option>
                  <option value="wifi">WiFi</option>
                </select>
                <div style="display:flex;align-items:center;gap:6px">
                  <div style="font-size:11px;color:#6b7280">IP:</div>
                  <div id="connectionIP" style="font-family:ui-monospace,monospace;font-size:12px;font-weight:600;padding:4px 8px;background:#eef2ff;border-radius:6px;border:1px solid #c7d2fe">‚Äî</div>
                </div>
              </div>
            </div>
            <div class="helpbox">
              <div style="font-weight:600;margin-bottom:6px">Commands quick reference</div>
              <div>VERSION - request version</div>
              <div>REBOOT - reboot device</div>
              <div style="margin-top:12px;font-weight:600">Ableton Messages over OSC</div>
              <div><code>/reannounce</code></div>
              <div><code>/hello</code></div>
              <div><code>/trackname index "Name" actualTrack</code> - Example: <code>/trackname 0 "Kick" 0</code></div>
              <div><code>/ipupdate</code> - device IP update (WiFi mode)</div>
            </div>
          </div>
        </div>
      </div>

    </div>
    
    <!-- Footer -->
    <div class="footer-info">
      <div class="company">PlayOptix, LLC</div>
      <div class="serial" id="footerSerial">Serial Number: Loading...</div>
    </div>
  </div>

  <!-- Wi-Fi Modal (legacy - removed) -->

  <!-- Add Network Modal -->
  <div id="modalAddNetwork" style="display:none;position:fixed;top:0;left:0;right:0;bottom:0;background:rgba(0,0,0,.5);z-index:1001;padding:20px;overflow:auto">
    <div style="max-width:450px;margin:80px auto;background:white;border-radius:10px;overflow:hidden">
      <div class="hdr"><h1>‚ûï Join WiFi Network</h1></div>
      <div class="body">
        <label>Network Name (SSID)</label>
        <div style="display:flex;gap:8px;margin-bottom:12px">
          <select id="ssidDropdown" class="input" style="flex:1;padding:6px 8px" title="Select WiFi network or type manually">
            <option value="">Select or type SSID‚Ä¶</option>
          </select>
          <button id="btnScanModal" class="btn ghost sm" title="Scan for networks">üîÑ</button>
        </div>
        <input id="ssidInput" class="input" placeholder="Or type network name manually" style="margin-bottom:12px;display:none" autocomplete="off" autocapitalize="off" spellcheck="false" data-lpignore="true" inputmode="text" name="tds8_ssid"/>
        
        <label>Password</label>
        <input id="pwd" class="input" type="password" placeholder="Enter password" style="margin-bottom:16px" autocomplete="new-password" data-lpignore="true" name="tds8_wifi_password"/>
        
        <div class="btn-group">
          <button id="btnSaveNetwork" class="btn primary">Save & Connect</button>
          <button id="btnCancelAdd" class="btn ghost">Cancel</button>
        </div>
      </div>
    </div>
  </div>

  <!-- Firmware Modal -->
  <div id="modalFirmware" style="display:none;position:fixed;top:0;left:0;right:0;bottom:0;background:rgba(0,0,0,.5);z-index:1000;padding:20px;overflow:auto">
    <div style="max-width:500px;margin:60px auto;background:white;border-radius:10px;overflow:hidden">
      <div class="hdr"><h1>‚¨áÔ∏è Firmware Updates</h1></div>
      <div class="body">
        <div id="firmwareStatus" style="text-align:center;padding:20px">
          <div style="font-size:48px;margin-bottom:12px">üîç</div>
          <p style="color:var(--muted);font-size:13px">Click Check for Updates to begin</p>
        </div>
        
        <div class="btn-group" style="justify-content:center">
          <button id="btnCheck" class="btn primary">Check for Updates</button>
          <button id="btnOta" class="btn secondary" style="display:none">Install Update</button>
          <button id="btnCloseFirmware" class="btn ghost">Close</button>
        </div>
      </div>
    </div>
  </div>

<script>
const $ = s => document.querySelector(s);
const logEl = $('#log');
let autoScrollEnabled = true;
const autoScrollCb = $('#autoScroll');
if (autoScrollCb) {
  autoScrollEnabled = !!autoScrollCb.checked;
  autoScrollCb.addEventListener('change', (e) => {
    autoScrollEnabled = !!e.target.checked;
    if (autoScrollEnabled && logEl) {
      requestAnimationFrame(() => { logEl.scrollTop = logEl.scrollHeight; });
    }
  });
}
// Periodically ensure we stay pinned to bottom when enabled
setInterval(() => {
  if (autoScrollEnabled && logEl) {
    logEl.scrollTop = logEl.scrollHeight;
  }
}, 500);
let connectedDevices = new Map();
let currentDevice = null;
let deviceCounter = 0;
let savedWifiNetworks = [];
let deviceSerialNumber = 'Unknown';
let currentConnectionType = 'none'; // 'none', 'wired', 'wifi'
let currentConnectionIP = '‚Äî';
let deviceVersions = new Map(); // Store firmware versions by port path
let deviceIdMap = new Map(); // Map serial numbers to device IDs for persistence
let isM4LConnected = false;

function updateM4LStatus(isConnected) {
  isM4LConnected = isConnected;
  // Update all visible device items
  document.querySelectorAll('.m4l-status').forEach(el => {
    el.innerHTML = isConnected
      ? `<span style="color:#10b981;">‚úì M4L Connected</span>`
      : `<span style="color:#ef4444;">‚ö†Ô∏è M4L Disconnected</span>`;
  });
}

// Update connection status banner
function updateConnectionBanner(type, ip) {
  console.log(`üîÑ updateConnectionBanner called: type=${type}, ip=${ip}`);
  currentConnectionType = type;
  currentConnectionIP = ip || '‚Äî';
  
  const typeSelect = $('#connectionTypeSelect');
  const ipEl = $('#connectionIP');
  const banner = $('#connectionBanner');
  
  console.log(`üîç Elements found: typeSelect=${!!typeSelect}, ipEl=${!!ipEl}, banner=${!!banner}`);
  
  // Update dropdown selection
  if (typeSelect) {
    typeSelect.value = type || 'wired';
  }
  
  // Show/hide inline WiFi controls
  const wifiControls = document.getElementById('wifiInlineControls');
  if (wifiControls) wifiControls.style.display = (type === 'wifi') ? 'flex' : 'none';

  // Update banner styling based on type
  if (type === 'wired') {
    banner.style.background = 'linear-gradient(135deg,#10b981 0%,#059669 100%)';
  } else if (type === 'wifi') {
    banner.style.background = 'linear-gradient(135deg,#3b82f6 0%,#2563eb 100%)';
  } else {
    banner.style.background = 'linear-gradient(135deg,#6b7280 0%,#4b5563 100%)';
  }
  
  // Update IP address
  if (ipEl) {
    ipEl.textContent = ip || '‚Äî';
  }
}

// Load saved networks from localStorage
function loadSavedNetworks() {
  const saved = localStorage.getItem('tds8_wifi_networks');
  if (saved) {
    try {
      savedWifiNetworks = JSON.parse(saved);
    } catch (e) {
      savedWifiNetworks = [];
    }
  }
}

function saveSavedNetworks() {
  localStorage.setItem('tds8_wifi_networks', JSON.stringify(savedWifiNetworks));
}

function log(msg, type = 'info') {
  const line = document.createElement('div');
  line.className = 'log-line ' + type;
  line.textContent = msg;
  logEl.appendChild(line);
  
  // Auto-scroll if enabled; do it after layout to ensure it sticks
  if (autoScrollEnabled) {
    logEl.scrollTop = logEl.scrollHeight;
    requestAnimationFrame(() => { logEl.scrollTop = logEl.scrollHeight; });
  }
}

function updateFooterSerial(serialNum) {
  deviceSerialNumber = serialNum || 'Unknown';
  $('#footerSerial').textContent = `Serial Number: ${deviceSerialNumber}`;
}

function updateConnectionStatus(connected) {
  const statusEl = $('#statusText');
  if (statusEl) {
    if (connected) {
      statusEl.textContent = 'üîå Connected';
      statusEl.style.color = '#10b981';
    } else {
      statusEl.textContent = 'Disconnected';
      statusEl.style.color = 'var(--muted)';
    }
  }
}

// ----- Device Management -----
async function scanDevices() {
  try {
    console.log('[scanDevices] Fetching /api/ports...');
    const res = await fetch('/api/ports');
    console.log(`[scanDevices] Response status: ${res.status}`);
    if (!res.ok) throw new Error(`Server error: ${res.status}`);
    const rawResponse = await res.text();
    console.log('[scanDevices] Raw response:', rawResponse);
    const ports = JSON.parse(rawResponse);
    console.log('[scanDevices] Parsed ports:', ports);
    
    // Fetch device status to get connection info
    const statusRes = await fetch('/api/device-status');
    const deviceStatus = await statusRes.json();
    const deviceInfoMap = new Map();
    if (deviceStatus.devices) {
      deviceStatus.devices.forEach(d => {
        deviceInfoMap.set(d.path, d);
      });
    }
    
    const list = $('#deviceList');
    list.innerHTML = '';
    
    if (!Array.isArray(ports) || ports.length === 0) {
      list.innerHTML = '<div style="text-align:center;padding:12px;color:var(--muted);font-size:12px">No TDS-8 devices found. Please connect via USB.<br><small style="color:#888">Try clicking Refresh or use manual COM connect below.</small></div>';
      updateFooterSerial(null);
      return;
    }
  
  // Sort ports by backend-reported device ID so rows appear as 1-8, 9-16, etc.
  const portsWithId = ports.map(p => ({ p, id: (deviceInfoMap.get(p.path) && typeof deviceInfoMap.get(p.path).id === 'number') ? deviceInfoMap.get(p.path).id : null }));
  portsWithId.sort((a, b) => {
    const ai = (a.id !== null) ? a.id : 99;
    const bi = (b.id !== null) ? b.id : 99;
    if (ai !== bi) return ai - bi;
    // stable fallback by path
    return String(a.p.path).localeCompare(String(b.p.path));
  });

  portsWithId.forEach((row, idx) => {
    const p = row.p;
    const item = document.createElement('div');
    item.className = 'device-item';
    const isConnected = connectedDevices.has(p.path);
    if (isConnected) item.classList.add('connected');
    
    const deviceNum = idx + 1;
    const deviceName = `TDS-8 #${deviceNum}`;
    
    // Show "TDS-8" with port name
    const portName = p.path.split('/').pop(); // Get last part of path (e.g., "cu.usbmodem101")
    const displayName = isConnected ? `TDS-8 (${portName})` : `${deviceName} (${portName})`;
    
    // Get firmware version and device info if available
    const version = deviceVersions.get(p.path);
    const versionBadge = version ? `<span style="font-size:10px;padding:2px 6px;background:#10b981;color:#fff;border-radius:4px;margin-left:8px">v${version}</span>` : '';
    
    // Get device ID and track range from backend status (preferred)
    const devInfo = deviceInfoMap.get(p.path);
    const currentId = devInfo && typeof devInfo.id === 'number' ? devInfo.id : (connectedDevices.get(p.path)?.deviceId ?? null);
    const trackRangeStr = currentId !== null ? `${currentId * 8 + 1}-${(currentId + 1) * 8}` : '';
    const deviceIdLabel = currentId !== null ? `Device ${currentId + 1}` : '';
    const trackInfo = currentId !== null ? ` - Tracks ${trackRangeStr}` : '';
    
    const statusText = isConnected 
      ? `<div class="device-status">‚úì Connected via ${currentConnectionType === 'wifi' ? 'WiFi' : 'USB'} - ${deviceIdLabel}${trackInfo}</div>` 
      : `<div style="font-size:11px;color:#6b7280;margin-top:2px">‚ö™ Disconnected</div>`;
    
    // Create device item HTML
    const deviceIdOptions = [0, 1, 2, 3].map(id => 
      `<option value="${id}" ${id === (currentId ?? idx) ? 'selected' : ''}>Tracks ${id * 8 + 1}-${(id + 1) * 8}</option>`
    ).join('');
    
    // Determine connection info for this device
    let deviceConnectionInfo = '‚ö™ Not Connected';
    if (isConnected && devInfo) {
      const mode = devInfo.mode || 'wired';
      const ip = devInfo.ip || '127.0.0.1';
      if (mode === 'wifi') {
        deviceConnectionInfo = `üì° WiFi (${ip}:8000)`;
      } else {
        deviceConnectionInfo = `üìç USB Serial (${ip})`;
      }
    } else if (isConnected) {
      deviceConnectionInfo = 'üìç USB Serial (127.0.0.1)';
    }
    
    item.innerHTML = `
      <div style="display:flex;align-items:center;gap:12px;flex:1">
        <div style="flex:1">
          <div class="device-name">${displayName}${versionBadge}</div>
          ${statusText}
          <div style="font-size:10px;color:#888;margin-top:2px;font-family:monospace">${deviceConnectionInfo}</div>
          <div class="m4l-status" style="font-size:11px;margin-top:2px">${isM4LConnected ? '<span style="color:#10b981;">‚úì M4L Connected</span>' : '<span style="color:#ef4444;">‚ö†Ô∏è M4L Disconnected</span>'}</div>
        </div>
      </div>
      <div style="display:flex;align-items:center;gap:8px;flex-wrap:wrap">
        <button class="btn ghost sm" title="Move Up" onclick="moveDevice('${p.path}','up')">‚ñ≤</button>
        <button class="btn ghost sm" title="Move Down" onclick="moveDevice('${p.path}','down')">‚ñº</button>
        <select class="input sm" style="width:140px;font-size:11px;padding:4px 6px" data-path="${p.path}" onchange="changeDeviceId('${p.path}', this.value)">
          ${deviceIdOptions}
        </select>
        ${isConnected ? 
          `<button class="btn ghost sm" onclick="forceWiredMode('${p.path}')">Force Wired</button>
           <button class="btn ghost sm" onclick="disconnect('${p.path}')">Disconnect</button>` :
          `<button class="btn primary sm" onclick="connect('${p.path}', '${deviceName}', '${p.serialNumber || ''}')">Connect</button>`
        }
      </div>
    `;
    
    // Add click handler for device item
    item.onclick = (e) => {
      if (e.target.tagName !== 'BUTTON') {
        if (!isConnected) {
          connect(p.path, deviceName, p.serialNumber || '');
        }
      }
    };
    
    list.appendChild(item);
    
    // Update footer with serial number if connected
    if (isConnected && p.serialNumber) {
      updateFooterSerial(p.serialNumber);
    }
    
    // No auto-assignment here; we reflect backend order and selections
  
  });
  
  // end of scanDevices list rendering
  } catch (err) {
    log(`‚úó Error scanning devices: ${err.message}`, 'err');
    console.error('Scan error:', err);
  }
}

async function connect(path, name, serialNum, retryCount = 0) {
  try {
    log(`üîå Connecting to ${name || path}...`, 'info');
    
    // Check if this device has a saved ID (by serial number) or manually selected ID
    let deviceId;
    
    // First check if user manually selected an ID via dropdown
    const selector = document.querySelector(`select[data-path="${path}"]`);
    const manualId = selector ? parseInt(selector.value) : null;
    
    if (manualId !== null && !isNaN(manualId)) {
      // Use manually selected ID
      deviceId = manualId;
      if (serialNum) {
        deviceIdMap.set(serialNum, deviceId);
      }
      log(`üëÜ Using manually selected Device ID ${deviceId}`, 'info');
    } else if (serialNum && deviceIdMap.has(serialNum)) {
      // Restore previously saved ID
      deviceId = deviceIdMap.get(serialNum);
      log(`üìå Restored Device ID ${deviceId} for serial ${serialNum}`, 'info');
    } else {
      // Auto-assign next available ID (0-3)
      const usedIds = new Set(Array.from(deviceIdMap.values()));
      deviceId = 0;
      while (usedIds.has(deviceId) && deviceId < 4) {
        deviceId++;
      }
      if (serialNum) {
        deviceIdMap.set(serialNum, deviceId);
        log(`üÜï Auto-assigned Device ID ${deviceId} to serial ${serialNum}`, 'info');
      }
    }
    
    const trackRange = `${deviceId * 8 + 1}-${(deviceId + 1) * 8}`;
    
    const res = await fetch('/api/connect', { 
      method:'POST', 
      headers:{'Content-Type':'application/json'}, 
      body: JSON.stringify({ path, deviceId }) // Pass device ID to backend
    });
    const j = await res.json();
    if (j.ok) {
      connectedDevices.set(path, { name, path, serialNum, deviceId, trackRange });
      currentDevice = path;
      updateFooterSerial(serialNum);
      updateConnectionStatus(true);
      updateConnectionBanner('wired', '127.0.0.1');
      
      // Backend now sends DEVICE_ID command, no need to send it here
      
      // Wait for version info before logging
      setTimeout(() => {
        const version = deviceVersions.get(path) || 'Unknown';
        log(`‚úì Connected to ${name || path} v${version} - Device ID ${deviceId} - Tracks ${trackRange}`, 'out');
      }, 1000);
      
      scanDevices();
      buildTrackGrid(); // Rebuild track grid with new device rows
      
          } else {
      log(`‚úó Connection failed: ${j.error || 'Unknown error'}`, 'err');
      // Only retry once
      if (retryCount < 1) {
        setTimeout(() => {
          log('üîÑ Retrying connection (1/1)...', 'info');
          connect(path, name, serialNum, retryCount + 1);
        }, 1000);
      } else {
        log('‚úó Connection failed after retry. Try manual COM port or click Refresh.', 'err');
      }
    }
  } catch (err) {
    log(`‚úó Connection error: ${err.message}`, 'err');
    console.error('Connect error:', err);
  }
}

async function changeDeviceId(path, newDeviceId) {
  const deviceId = parseInt(newDeviceId);
  log(`üîÑ Remapping ${path} to Device ID ${deviceId} (Tracks ${deviceId * 8 + 1}-${(deviceId + 1) * 8})`, 'info');
  try {
    const r = await fetch('/api/remap-device-ids', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ path, deviceId })
    });
    const j = await r.json();
    if (!r.ok || !j.ok) throw new Error(j && j.error ? j.error : `HTTP ${r.status}`);
    log('‚úì Device IDs updated', 'out');
    setTimeout(() => scanDevices(), 400);
  } catch (e) {
    log(`‚úó Failed to remap IDs: ${e.message}`, 'err');
  }
}

async function refreshFromAbleton() {
  log('üì£ Requesting track list from Ableton (/reannounce)‚Ä¶', 'info');
  // UI guard: disable Update All Tracks for ~30s during refresh window
  try {
    const btnSendAll = document.getElementById('btnSendAll');
    if (btnSendAll) {
      btnSendAll.disabled = true;
      btnSendAll.classList.add('disabled');
      btnSendAll.title = 'Disabled during Ableton refresh window (~30s)';
      setTimeout(() => { btnSendAll.disabled = false; btnSendAll.classList.remove('disabled'); btnSendAll.title = ''; }, 30000);
    }
  } catch {}
  try {
    const r = await fetch('/api/reannounce', { method: 'POST' });
    const j = await r.json();
    if (!r.ok || !j.ok) throw new Error(j && j.error ? j.error : `HTTP ${r.status}`);
    log('‚úì /reannounce sent to M4L. Awaiting track updates‚Ä¶', 'out');
  } catch (e) {
    log(`‚úó Failed to send /reannounce: ${e.message}`, 'err');
  }
}

// Move a device up or down by swapping its Device ID
async function moveDevice(path, dir) {
  try {
    const res = await fetch('/api/device-status');
    const st = await res.json();
    if (!res.ok || !st.ok) throw new Error('Status fetch failed');
    const devs = st.devices || [];
    const cur = devs.find(d => d.path === path);
    if (!cur || typeof cur.id !== 'number') throw new Error('Device not found or ID missing');
    const targetId = dir === 'up' ? (cur.id - 1) : (cur.id + 1);
    if (targetId < 0 || targetId >= 4) { log('‚ö†Ô∏è Already at boundary', 'info'); return; }
    const resp = await fetch('/api/remap-device-ids', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ path, deviceId: targetId })
    });
    const j = await resp.json();
    if (!resp.ok || !j.ok) throw new Error(j && j.error ? j.error : `HTTP ${resp.status}`);
    // Re-render list sorted by backend IDs
    setTimeout(() => scanDevices(), 300);
  } catch (e) {
    log(`‚úó Move failed: ${e.message}`, 'err');
  }
}

function forceWiredMode(path) {
  log(`üîå Forcing device on ${path} to wired mode...`, 'info');
  
  // Send commands to force wired mode
  fetch('/api/send-command', {
    method: 'POST',
    headers: {'Content-Type': 'application/json'},
    body: JSON.stringify({ 
      command: 'WIRED_ONLY true',
      path: path
    })
  }).then(() => {
    log(`‚úì Sent WIRED_ONLY true`, 'out');
    // Wait a moment, then send FORGET to clear WiFi credentials
    return fetch('/api/send-command', {
      method: 'POST',
      headers: {'Content-Type': 'application/json'},
      body: JSON.stringify({ 
        command: 'FORGET',
        path: path
      })
    });
  }).then(() => {
    log(`‚úì Sent FORGET (cleared WiFi credentials)`, 'out');
    log(`üîÑ Rebooting device...`, 'info');
    // Reboot the device
    return fetch('/api/send-command', {
      method: 'POST',
      headers: {'Content-Type': 'application/json'},
      body: JSON.stringify({ 
        command: 'REBOOT',
        path: path
      })
    });
  }).then(() => {
    log(`‚úì Device will reboot in wired mode`, 'out');
    // Immediately inform M4L of wired localhost IP
    fetch('/api/broadcast-ip', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ ip: '127.0.0.1', mode: 'wired' })
    }).catch(() => {});
    setTimeout(() => scanDevices(), 3000);
  }).catch(err => {
    log(`‚úó Failed to force wired mode: ${err.message}`, 'err');
  });
}

function disconnect(path) {
  // Send disconnect request to server to release serial port
  fetch('/api/disconnect', {
    method: 'POST',
    headers: {'Content-Type': 'application/json'},
    body: JSON.stringify({ path })
  }).catch(err => console.error('Disconnect error:', err));
  
  connectedDevices.delete(path);
  if (currentDevice === path) {
    currentDevice = null;
    updateFooterSerial(null);
    updateConnectionStatus(false);
    updateConnectionBanner('none', '‚Äî');
    // Reset connection UI (legacy WiFi elements removed)
    // const wifiStatus = $('#wifiStatus');
    // const wifiSelect = $('#wifiNetworkSelect');
    // const wiredStatus = $('#wiredStatus');
    // const wiredBtn = $('#btnWiredConnect');
    // const comSelect = $('#comPortSelect');
    // 
    // if (wifiStatus) { wifiStatus.textContent = 'Disconnected'; wifiStatus.style.background = '#e5e7eb'; wifiStatus.style.color = '#6b7280'; }
    // if (wifiSelect) wifiSelect.style.backgroundColor = '';
    // if (wiredStatus) { wiredStatus.textContent = 'Disconnected'; wiredStatus.style.background = '#e5e7eb'; wiredStatus.style.color = '#6b7280'; }
    // if (wiredBtn) { wiredBtn.textContent = 'Connect'; wiredBtn.className = 'btn primary sm'; }
    // if (comSelect) comSelect.style.backgroundColor = '';
  }
  log(`‚úì Disconnected from device - Serial port released for Arduino IDE`, 'info');
  scanDevices();
}

// ----- Track Names -----
let currentOffset = 0;

function updateOffsetUI() {
  const start = currentOffset + 1;
  const end = currentOffset + 8;
  const offDisplay = $('#offsetDisplay');
  const offRange = $('#offsetRange');
  if (offDisplay) offDisplay.textContent = String(currentOffset);
  if (offRange) offRange.textContent = `${start}-${end}`;
}

function buildTrackGrid() {
  const host = $('#tracks');
  host.innerHTML = '';
  // Show 8 fields per connected device, default to 8 if none connected
  let numDevices = connectedDevices && connectedDevices.size > 0 ? connectedDevices.size : 1;
  let totalTracks = Math.min(numDevices * 8, 32);
  for (let globalIdx = 0; globalIdx < totalTracks; globalIdx++) {
    // Insert visual separators between groups of 8 (1-8 | 9-16 | 17-24 | 25-32)
    if (globalIdx > 0 && globalIdx % 8 === 0) {
      const sep = document.createElement('div');
      sep.className = 'track-sep';
      host.appendChild(sep);
    }
    const row = document.createElement('div');
    row.className = 'trackrow';
    const label = document.createElement('label');
    label.textContent = `Track ${globalIdx + 1}`;
    const input = document.createElement('input');
    input.className = 'input';
    input.id = 'tname' + globalIdx;
    input.name = `track-${globalIdx}`;
    input.value = String(globalIdx + 1);
    input.placeholder = `${globalIdx + 1}`;
    input.oninput = () => saveLocalTrackNames();
    row.appendChild(label);
    row.appendChild(input);
    host.appendChild(row);
  }
}

// ----- Local persistence for Track Names -----
function saveLocalTrackNames() {
  const names = [];
  // Save up to 32 tracks
  for (let i = 0; i < 32; i++) {
    const el = document.getElementById('tname' + i);
    names.push(el ? el.value : '');
  }
  try { localStorage.setItem('tds8_tracknames', JSON.stringify(names)); } catch {}
}

function loadLocalTrackNames() {
  try {
    const raw = localStorage.getItem('tds8_tracknames');
    if (!raw) return false;
    const names = JSON.parse(raw);
    if (!Array.isArray(names)) return false;
    
    // Check if localStorage contains placeholder text or just numbers and clear it
    const hasPlaceholders = names.some(name => {
      if (!name) return false;
      // Match "Track 1", "Track 2", etc. OR just numbers "1", "2", "9", "10", etc.
      return /^Track \d+$/i.test(name) || /^\d+$/.test(name);
    });
    if (hasPlaceholders) {
      console.log('‚ö†Ô∏è Clearing localStorage with placeholder/number text');
      localStorage.removeItem('tds8_tracknames');
      return false;
    }
    
    // Load up to 32 tracks (or however many are in storage)
    for (let i = 0; i < Math.min(32, names.length); i++) {
      const el = document.getElementById('tname' + i);
      if (el && names[i]) {  // Only set if there's a non-empty value
        el.value = names[i];
      }
    }
    log('‚úì Loaded track names from localStorage', 'info');
    return true;
  } catch { return false; }
}

function resetTracks() {
  const numDevices = Math.max(1, connectedDevices.size);
  const totalTracks = Math.min(numDevices * 8, 32);
  
  // Clear all track inputs
  for (let i = 0; i < totalTracks; i++) {
    const inputElement = document.getElementById('tname' + i);
    if (inputElement) {
      inputElement.value = String(i + 1);  // Set to numeric default
    }
  }
  
  // Clear localStorage
  try { localStorage.removeItem('tds8_tracknames'); } catch {}
  
  log(`‚úì Cleared all track names`, 'info');
};

async function saveTracksToBridge() {
  log('üíæ Saving track names to bridge...', 'info');
  const names = [];
  for (let i = 0; i < 32; i++) {
    const el = document.getElementById('tname' + i);
    names.push(el ? el.value : '');
  }

  try {
    const res = await fetch('/api/tracknames', {
      method: 'POST',
      headers: {'Content-Type': 'application/json'},
      body: JSON.stringify({ names })
    });
    const data = await res.json();
    if (data.ok) {
      log('‚úì Track names saved to bridge successfully', 'out');
    } else {
      log(`‚úó Failed to save track names: ${data.error || 'Unknown error'}`, 'err');
    }
  } catch (err) {
    log(`‚úó Error saving track names: ${err.message}`, 'err');
  }
}

// All button handlers moved to DOMContentLoaded

// Duplicate function removed - using the correct one above that calls /api/reannounce

// ---- WebSocket: stream logs and state from Bridge ----
function initWebSocket() {
  try {
    const proto = location.protocol === 'https:' ? 'wss' : 'ws';
    const ws = new WebSocket(`${proto}://${location.host}`);
    ws.onopen = () => { log('‚úì WebSocket connected to Bridge', 'info'); };
    ws.onclose = () => { log('‚úó WebSocket disconnected from Bridge', 'err'); };
    ws.onerror = () => { log('‚úó WebSocket error', 'err'); };
    ws.onmessage = (evt) => {
      let msg;
      try { msg = JSON.parse(evt.data); } catch { return; }
      if (!msg || !msg.type) return;
      switch (msg.type) {
        case 'serial-data':
          if (msg.data) log(String(msg.data));
          break;
        case 'osc-sent': {
          const a = msg.address || '';
          const args = Array.isArray(msg.args) ? msg.args.map(x => x.value ?? x).join(', ') : (msg.argsStr || '');
          log(`OSC ‚Üí ${a}${args ? ' [' + args + ']' : ''}`, 'out');
          break;
        }
        case 'osc-received': {
          const a = msg.address || '';
          const args = Array.isArray(msg.args) ? msg.args.map(x => x.value ?? x).join(', ') : '';
          if (msg.address === '/trackname' && connectedDevices.size === 0) {
              // Silently ignore to prevent log spam on startup
            } else {
              log(`OSC ‚Üê ${a}${args ? ' [' + args + ']' : ''}`, 'in');
            }
          break;
        }
        case 'device-ip': {
          const ip = msg.ip || '‚Äî';
          const type = msg.connectionType || (ip === '127.0.0.1' ? 'wired' : 'wifi');
          updateConnectionBanner(type, ip);
          
          // Update device-specific connection info if provided
          if (msg.devices && Array.isArray(msg.devices)) {
            msg.devices.forEach(deviceInfo => {
              console.log(`üì± Device ${deviceInfo.id} mode update:`, deviceInfo.mode, deviceInfo.ip);
            });
            // Refresh device list to show updated connection info
            scanDevices();
          }
          break;
        }
        case 'device-mode': {
          const ip = msg.ip || '‚Äî';
          const type = msg.mode || (ip === '127.0.0.1' ? 'wired' : 'wifi');
          updateConnectionBanner(type, ip);
          break;
        }
        case 'device-version': {
          if (msg.path) {
            deviceVersions.set(msg.path, msg.version || '');
            scanDevices();
          }
          break;
        }
        case 'device-connected':
        case 'serial-open':
        case 'serial-close':
        case 'serial-error':
          scanDevices();
          break;
        case 'ableton-connected':
          updateM4LStatus(true);
          log('‚úì Ableton connected (heartbeat /hi)', 'out');
          break;
        case 'ableton-disconnected':
          updateM4LStatus(false);
          log('‚ö†Ô∏è Ableton disconnected (no /hi)', 'err');
          break;
      }
    };
  } catch (e) {
    log(`‚úó WebSocket init failed: ${e.message}`, 'err');
  }
}

// Send track names for a specific device based on its device ID
async function sendTrackNamesForDevice(deviceId) {
  const startTrack = deviceId * 8;
  const endTrack = startTrack + 8;
  
  let count = 0;
  for (let i = startTrack; i < endTrack; i++) {
    const inputElement = document.getElementById('tname' + i);
    const name = inputElement ? inputElement.value.trim() : '';
    
    if (name) {
      const localIndex = i - startTrack;
      const payload = { index: localIndex, name, actualTrack: i };
      console.log(`[AUTO-SEND] Track ${i} to Device ${deviceId}, local index ${localIndex}: "${name}"`);
      await fetch('/api/trackname', {
        method: 'POST',
        headers: {'Content-Type': 'application/json'},
        body: JSON.stringify(payload)
      });
      count++;
      await new Promise(r => setTimeout(r, 20));
    }
  }
  
  if (count > 0) {
    log(`‚úì Sent ${count} track names to Device ${deviceId} (Tracks ${startTrack + 1}-${endTrack})`, 'out');
  }
}

async function sendAllTracks() {
  console.log('[DEBUG] sendAllTracks called');
  // UI guard: disable Refresh for ~30s to avoid UI+OSC overlap
  try {
    const btnRefresh = document.getElementById('btnRefresh');
    if (btnRefresh) {
      btnRefresh.disabled = true;
      btnRefresh.classList.add('disabled');
      btnRefresh.title = 'Disabled for 30s after Update All Tracks to avoid duplicates';
      setTimeout(() => { btnRefresh.disabled = false; btnRefresh.classList.remove('disabled'); btnRefresh.title = ''; }, 30000);
    }
  } catch {}
  console.log('[DEBUG] currentDevice:', currentDevice);
  console.log('[DEBUG] connectedDevices.size:', connectedDevices.size);
  console.log('[DEBUG] connectedDevices:', Array.from(connectedDevices.entries()));
  
  // Check if any device is connected
  if (!currentDevice && connectedDevices.size === 0) {
    log('‚úó Please connect to a TDS-8 device first', 'err');
    log('Click "Connect" button on a device in the TDS-8 Devices section above', 'info');
    return;
  }

  log('üì§ Sending track names to connected devices...', 'info');
  
  const trackToDevice = new Map();
  connectedDevices.forEach((deviceInfo, path) => {
    console.log('[DEBUG] Processing device:', path, deviceInfo);
    const deviceId = deviceInfo.deviceId;
    const startTrack = deviceId * 8;
    const endTrack = startTrack + 8;
    console.log(`[DEBUG] Device ${deviceId}: tracks ${startTrack}-${endTrack-1}`);
    for (let t = startTrack; t < endTrack; t++) {
      trackToDevice.set(t, { deviceId, localIndex: t - startTrack });
    }
  });

  // Fallback for single-device mode when map hasn't been populated yet
  if (trackToDevice.size === 0 && currentDevice) {
    console.log('[DEBUG] Fallback: assuming single device with Device ID 0');
    for (let t = 0; t < 8; t++) {
      trackToDevice.set(t, { deviceId: 0, localIndex: t });
    }
  }
  
  console.log('[DEBUG] trackToDevice map:', Array.from(trackToDevice.entries()));
  
  let count = 0;
  for (let i = 0; i < 32; i++) {
    const inputElement = document.getElementById('tname' + i);
    const name = inputElement ? inputElement.value.trim() : '';
    if (name) {
      console.log(`[DEBUG] Track ${i} has name: "${name}", has mapping: ${trackToDevice.has(i)}`);
    }
    if (name && trackToDevice.has(i)) {
      const { deviceId, localIndex } = trackToDevice.get(i);
      const payload = { index: localIndex, name, actualTrack: i };
      console.log(`[DEBUG] Sending track ${i}:`, payload);
      try {
        const res = await fetch('/api/trackname', {
          method: 'POST',
          headers: {'Content-Type': 'application/json'},
          body: JSON.stringify(payload)
        });
        if (!res.ok) {
          const error = await res.json();
          log(`‚úó Failed to send track ${i}: ${error.error || 'Unknown error'}`, 'err');
        } else {
          count++;
          console.log(`[DEBUG] Successfully sent track ${i}`);
        }
      } catch (err) {
        log(`‚úó Error sending track ${i}: ${err.message}`, 'err');
        console.error('[DEBUG] Error:', err);
      }
      await new Promise(r => setTimeout(r, 20));
    }
  }
  saveLocalTrackNames();
  if (count > 0) {
    log(`‚úì Updated ${count} track names to connected devices`, 'out');
  } else {
    log('‚ö†Ô∏è No track names were sent (fields may be empty or no devices connected)', 'info');
  }
}

// ----- Modals -----

// Shared WiFi scan function
async function scanWiFiNetworks() {
  log('üì° Scanning for WiFi networks...', 'info');
  try {
    const res = await fetch('/api/wifi-scan');
    const data = await res.json();
    if (data.ok && data.ssids) {
      scannedNetworks = data.ssids;
      displayNetworkList();
      // Also populate top bar dropdown
      const wifiSelect = $('#wifiNetworkSelect');
      if (wifiSelect) {
        wifiSelect.innerHTML = '<option value="">Select WiFi network...</option>';
        data.ssids.forEach(ssid => {
          const option = document.createElement('option');
          option.value = ssid;
          option.textContent = ssid;
          wifiSelect.appendChild(option);
        });
      }
      log(`‚úì Found ${data.ssids.length} networks`, 'out');
    } else {
      log(`‚úó Scan failed: ${data.error || 'Unknown error'}`, 'err');
    }
  } catch (err) {
    log(`‚úó Scan error: ${err.message}`, 'err');
  }
}

// All WiFi and Firmware button handlers moved to DOMContentLoaded

  // Old WiFi functions (replaced by modal system)
  // function displayNetworkList() - removed
  // function connectToNetwork() - removed
  // function saveNetwork() - removed
  // function scanWiFiNetworks() - removed (replaced by scanWiFiModal)
  // let scannedNetworks = [] - no longer needed
const MANIFEST_URL = 'https://raw.githubusercontent.com/m1llipede/tds8/main/manifest.json';

async function checkFirmware() {
  if (!currentDevice) {
    const status = $('#firmwareStatus');
    status.innerHTML = `
      <div style="font-size:48px;margin-bottom:12px">‚ö†Ô∏è</div>
      <h3 style="margin:0 0 8px;color:var(--text);font-size:15px">No Device Connected</h3>
      <p style="color:var(--muted);margin:0;font-size:12px">Please connect a TDS-8 device first</p>
    `;
    log('‚úó Please connect a device before checking for updates', 'err');
    return;
  }
  
  const status = $('#firmwareStatus');
  status.innerHTML = '<div style="font-size:48px;margin-bottom:12px">‚è≥</div><p style="color:var(--muted);font-size:13px">Checking for updates...</p>';
  
  try {
    const url = new URL('/api/ota-check', window.location.origin);
    url.searchParams.set('manifest', MANIFEST_URL);
    
    const res = await fetch(url);
    const j = await res.json();
    
    if (j.ok) {
      const deviceVer = j.deviceVersion || 'Unknown';
      const latestVer = j.manifest.version;
      const isNewer = j.isNewer;
      
      if (isNewer) {
        status.innerHTML = `
          <div style="font-size:48px;margin-bottom:12px">üéâ</div>
          <h3 style="margin:0 0 8px;color:var(--text);font-size:15px">Update Available!</h3>
          <p style="color:var(--muted);margin:0;font-size:12px">Current: ${deviceVer} ‚Üí New: ${latestVer}</p>
        `;
        $('#btnOta').style.display = 'inline-flex';
        log(`Update available: ${latestVer}`, 'info');
      } else {
        status.innerHTML = `
          <div style="font-size:48px;margin-bottom:12px">‚úÖ</div>
          <h3 style="margin:0 0 8px;color:var(--text);font-size:15px">Up to Date</h3>
          <p style="color:var(--muted);margin:0;font-size:12px">Version ${deviceVer}</p>
        `;
        $('#btnOta').style.display = 'none';
        log(`Firmware is up to date (${deviceVer})`, 'info');
      }
    } else {
      status.innerHTML = `
        <div style="font-size:48px;margin-bottom:12px">‚ö†Ô∏è</div>
        <h3 style="margin:0 0 8px;color:var(--text);font-size:15px">Check Failed</h3>
        <p style="color:var(--muted);margin:0;font-size:12px">${j.error}</p>
      `;
      log(`‚úó Update check failed: ${j.error}`, 'err');
    }
  } catch (err) {
    const errorMsg = err.message.includes('404') 
      ? 'Firmware manifest not found. The update file may not exist yet at the GitHub repository.'
      : 'Could not reach update server. Check your internet connection.';
    
    status.innerHTML = `
      <div style="font-size:48px;margin-bottom:12px">‚ö†Ô∏è</div>
      <h3 style="margin:0 0 8px;color:var(--text);font-size:15px">Connection Error</h3>
      <p style="color:var(--muted);margin:0;font-size:12px">${errorMsg}</p>
    `;
    log(`‚úó Network error: ${err.message}`, 'err');
  }
};

async function startOTA() {
  if (!confirm('Start firmware update? Device will switch to Wi-Fi mode and update.')) return;
  
  const status = $('#firmwareStatus');
  status.innerHTML = '<div style="font-size:48px;margin-bottom:12px">‚¨áÔ∏è</div><p style="color:var(--muted);font-size:13px">Starting update...</p>';
  
  const res = await fetch('/api/ota-update', {
    method: 'POST',
    headers: {'Content-Type': 'application/json'},
    body: JSON.stringify({ manifest: MANIFEST_URL })
  });
  
  const j = await res.json();
  if (j.ok) {
    status.innerHTML = '<div style="font-size:48px;margin-bottom:12px">‚úÖ</div><p style="color:#10b981;font-size:13px">Update started! Device will reboot when complete.</p>';
    log('‚úì Firmware update started', 'out');
  } else {
    status.innerHTML = `<div style="font-size:48px;margin-bottom:12px">‚ö†Ô∏è</div><p style="color:#ef4444;font-size:13px">Update failed: ${j.error}</p>`;
    log(`‚úó Update failed: ${j.error}`, 'err');
  }
};

// ----- Commands -----
async function sendCmd(cmd) {
  cmd = (cmd || '').trim();
  if (!cmd) return;
  
  const res = await fetch('/api/send', {
    method: 'POST',
    headers: {'Content-Type': 'application/json'},
    body: JSON.stringify({ cmd })
  });
  
  const j = await res.json();
  if (j.ok) log(`‚Üí ${cmd}`, 'out');
  else log(`‚úó Send error: ${j.error}`, 'err');
}

function sendCommand() {
  sendCmd($('#cmd').value);
  $('#cmd').value = '';
}


// Duplicate WebSocket block removed ‚Äî using initWebSocket() only


// Helper function to load stored track names
async function loadStoredTrackNames() {
  try {
    const res = await fetch('/api/tracknames');
    const j = await res.json();
    if (j && j.ok && Array.isArray(j.names)) {
      for (let i = 0; i < 8; i++) {
        const input = document.getElementById('tname' + i);
        if (input) input.value = j.names[i] || '';
      }
      log('‚úì Loaded stored track names', 'info');
    } else {
      log(`‚úó Failed to load track names: ${j && j.error ? j.error : 'Unknown error'}`, 'err');
    }
  } catch (e) {
    log(`‚úó Failed to load track names: ${e.message}`, 'err');
  }
}

// Check device status on load - legacy WiFi elements removed
async function checkDeviceStatus() {
  try {
    const res = await fetch('/api/device-status');
    const data = await res.json();
    if (data.ok && data.connectionType !== 'none') {
      updateConnectionBanner(data.connectionType, data.ip);
      log(`Device already connected: ${data.connectionType} (${data.ip})`, 'info');
    }
  } catch (e) {
    console.error('Failed to check device status:', e);
  }
}

// ----- Init -----
window.addEventListener('DOMContentLoaded', () => {
  log('TDS-8 Control ready', 'info');
  
  buildTrackGrid();
  loadLocalTrackNames();
  scanDevices(); // Scan for devices on page load
  setInterval(scanDevices, 5000);
  checkDeviceStatus();
  // Start WebSocket stream for serial/OSC and device IP/mode updates
  initWebSocket();

  // Attach all button event listeners safely (inside DOMContentLoaded)
  const refreshBtn = document.getElementById('btnRefreshDevices');
  if (refreshBtn) {
    refreshBtn.onclick = async () => {
      log('üîÑ Manually refreshing device list...', 'info');
      await scanDevices();
      log('‚úì Device list refreshed', 'out');
    };

  
  }

  const btnRefresh = document.getElementById('btnRefresh');
  if (btnRefresh) btnRefresh.onclick = refreshFromAbleton;

  // Connection type dropdown handler
  const connectionTypeSelect = document.getElementById('connectionTypeSelect');
  if (connectionTypeSelect) {
    connectionTypeSelect.onchange = async (e) => {
      const newMode = e.target.value;
      log(`üîÑ Switching to ${newMode} mode...`, 'info');
      
      if (newMode === 'wired') {
        // Send WIRED_ONLY true to all devices and reboot
        try {
          const response = await fetch('/api/send', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ cmd: 'WIRED_ONLY true' })
          });
          const result = await response.json();
          if (result.ok) {
            log('‚úì Sent wired mode command', 'out');
            // Wait a moment then reboot
            setTimeout(async () => {
              await fetch('/api/send', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ cmd: 'REBOOT ALL' })
              });
              log('üîÑ Rebooting all devices to apply wired mode', 'info');
            }, 1000);
          }
        } catch (err) {
          log(`‚ùå Failed to switch to wired mode: ${err.message}`, 'error');
        }
      } else if (newMode === 'wifi') {
        // Show WiFi network selection dialog
        const wifiDialog = document.getElementById('wifiDialog');
        if (wifiDialog) {
          wifiDialog.style.display = 'block';
          scanWifiNetworks();
        }
      }
    };
  }

  const btnSendAll = document.getElementById('btnSendAll');
  if (btnSendAll) btnSendAll.onclick = sendAllTracks;

  const btnResetTracks = document.getElementById('btnResetTracks');
  if (btnResetTracks) {
    btnResetTracks.textContent = 'Reset Track Names';
    btnResetTracks.onclick = resetTracks;
  }

  const btnSaveTracks = document.getElementById('btnSaveTracks');
  if (btnSaveTracks) {
    btnSaveTracks.onclick = saveTracksToBridge;
  }

  // WiFi buttons (legacy handlers removed)
  // const btnScanNetworks = document.getElementById('btnScanNetworks');
  // if (btnScanNetworks) btnScanNetworks.onclick = scanWiFiNetworks;

  // const btnWifiScanQuick = document.getElementById('btnWifiScanQuick');
  // if (btnWifiScanQuick) btnWifiScanQuick.onclick = scanWiFiNetworks;

  // const btnAddNetwork = document.getElementById('btnAddNetwork');
  // if (btnAddNetwork) btnAddNetwork.onclick = () => $('#modalAddNetwork').style.display = 'block';

  // const btnCancelAdd = document.getElementById('btnCancelAdd');
  // if (btnCancelAdd) btnCancelAdd.onclick = () => $('#modalAddNetwork').style.display = 'none';

  // const btnSaveNetwork = document.getElementById('btnSaveNetwork');
  // if (btnSaveNetwork) btnSaveNetwork.onclick = saveNetwork;

  // const btnCloseWifi = document.getElementById('btnCloseWifi');
  // if (btnCloseWifi) btnCloseWifi.onclick = () => $('#modalWifi').style.display = 'none';

  // Firmware buttons
  const btnFirmwareTop = document.getElementById('btnFirmwareTop');
  if (btnFirmwareTop) {
    btnFirmwareTop.onclick = () => {
      $('#modalFirmware').style.display = 'block';
      if (currentDevice) {
        const btnCheck = $('#btnCheck');
        if (btnCheck) btnCheck.click();
      }
    };
  }

  const btnCloseFirmware = document.getElementById('btnCloseFirmware');
  if (btnCloseFirmware) btnCloseFirmware.onclick = () => $('#modalFirmware').style.display = 'none';

  const btnCheck = document.getElementById('btnCheck');
  if (btnCheck) btnCheck.onclick = checkFirmware;

  const btnOta = document.getElementById('btnOta');
  if (btnOta) btnOta.onclick = startOTA;

  // Command input
  const btnSend = document.getElementById('btnSend');
  if (btnSend) btnSend.onclick = sendCommand;

  const cmdInput = document.getElementById('cmd');
  if (cmdInput) {
    cmdInput.addEventListener('keydown', (e) => {
      if (e.key === 'Enter') sendCommand();
    });
  }

  // Legacy WiFi scan function (removed - replaced by scanWiFiModal)
  // async function scanWifiTop() { ... } - no longer needed

  // WiFi modal scan functionality
  async function scanWiFiModal() {
    const dropdown = document.getElementById('ssidDropdown');
    const scanBtn = document.getElementById('btnScanModal');
    if (!dropdown || !scanBtn) return;
    
    scanBtn.disabled = true;
    scanBtn.textContent = '‚è≥';
    
    try {
      log('üì° Scanning for WiFi networks...', 'info');
      const res = await fetch('/api/wifi-scan');
      const data = await res.json();
      if (!res.ok) throw new Error(data.error || 'scan failed');
      
      // Clear and refill dropdown
      dropdown.innerHTML = '<option value=\"\">Select or type SSID‚Ä¶</option>';
      if (data.ssids && Array.isArray(data.ssids)) {
        data.ssids.forEach(ssid => {
          if (ssid) {
            const opt = document.createElement('option');
            opt.value = ssid;
            opt.textContent = ssid;
            dropdown.appendChild(opt);
          }
        });
        log(`‚úì Found ${data.ssids.length} networks`, 'out');
      } else {
        // No networks found, add manual option
        dropdown.innerHTML = '<option value=\"\">Type SSID manually‚Ä¶</option>';
        log('‚ö†Ô∏è No networks found, enter manually', 'info');
      }
    } catch (e) {
      log(`‚úñ WiFi scan failed: ${e.message}`, 'error');
      dropdown.innerHTML = '<option value=\"\">Type SSID manually‚Ä¶</option>';
    } finally {
      scanBtn.disabled = false;
      scanBtn.textContent = 'üîÑ';
    }
  }

  // Show WiFi modal when switching to WiFi
  const typeSelect2 = document.getElementById('connectionTypeSelect');
  if (typeSelect2) {
    typeSelect2.addEventListener('change', (e) => {
      if (e.target.value === 'wifi') {
        const modal = document.getElementById('modalAddNetwork');
        if (modal) {
          modal.style.display = 'block';
          loadWifiCredentials(); // Autofill saved credentials
          // Auto-scan for networks
          setTimeout(() => scanWiFiModal(), 200);
        }
      } else {
        // Wired mode selected
        apiSend('WIRED_ONLY true').then(() => {
          setTimeout(() => apiSend('REBOOT ALL'), 500);
        });
      }
    });
  }
  
  // --- WiFi Modal Logic ---
  function loadWifiCredentials() {
    const savedSsid = localStorage.getItem('tds8_wifi_ssid');
    const savedPass = localStorage.getItem('tds8_wifi_pass');
    if (savedSsid) {
      const ssidInput = document.getElementById('ssidInput');
      const ssidDropdown = document.getElementById('ssidDropdown');
      if (ssidInput) ssidInput.value = savedSsid;
      if (ssidDropdown) {
        // Check if the saved SSID is already in the dropdown
        let found = false;
        for (let i = 0; i < ssidDropdown.options.length; i++) {
          if (ssidDropdown.options[i].value === savedSsid) {
            ssidDropdown.selectedIndex = i;
            found = true;
            break;
          }
        }
        if (!found) {
          // If not found, show the manual input
          ssidDropdown.value = '';
          ssidInput.style.display = 'block';
          ssidInput.value = savedSsid;
        }
      }
    }
    if (savedPass) {
      const pwdInput = document.getElementById('pwd');
      if (pwdInput) pwdInput.value = savedPass;
    }
  }

  // Save & Connect button handler (WiFi modal)
  const btnSaveNetwork = document.getElementById('btnSaveNetwork');
  if (btnSaveNetwork) btnSaveNetwork.onclick = async () => {
    const dropdown = document.getElementById('ssidDropdown');
    const manualInput = document.getElementById('ssidInput');
    const pwdInput = document.getElementById('pwd');
    
    let ssid = '';
    if (dropdown && dropdown.value && dropdown.value !== '') {
      ssid = dropdown.value;
    } else if (manualInput) {
      ssid = manualInput.value.trim();
    }
    
    const password = pwdInput ? pwdInput.value : '';
    if (!ssid) { log('SSID is required', 'error'); return; }
    try {
      // Save credentials to localStorage for autofill
      localStorage.setItem('tds8_wifi_ssid', ssid);
      localStorage.setItem('tds8_wifi_pass', password);

      log('üíæ WiFi credentials saved to browser for autofill.', 'info');

      // 1. Send WIFI_JOIN to all devices
      log('üì° Sending WiFi credentials to all connected devices...', 'info');
      const joinRes = await fetch('/api/wifi-join', {
        method: 'POST',
        headers: {'Content-Type': 'application/json'},
        body: JSON.stringify({ ssid, password })
      });
      const joinJson = await joinRes.json();
      if (!joinRes.ok) throw new Error(joinJson.error || 'WIFI_JOIN command failed');
      log('‚úì Credentials sent.', 'out');

      // 2. Send commands to switch to WiFi and reboot
      log('üîÑ Telling all devices to switch to WiFi mode and reboot...', 'info');
      const switchRes = await fetch('/api/wifi-switch-all', { method: 'POST' });
      const switchJson = await switchRes.json();
      if (!switchRes.ok) throw new Error(switchJson.error || 'WiFi switch command failed');
      
      log('‚úì WiFi switch command sent. Devices will disconnect and reboot.', 'out');
      log('Please wait a moment for them to reconnect over WiFi.', 'info');

      // Close modal
      const modal = document.getElementById('modalAddNetwork');
      if (modal) modal.style.display = 'none';

    } catch (err) {
      log(`‚úñ WiFi setup failed: ${err.message}`, 'error');
    }
  };

  // Quick actions
  async function apiSend(cmd) {
    if (!cmd) return;
    try {
      const res = await fetch('/api/send', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ cmd })
      });
      const j = await res.json();
      if (!res.ok) throw new Error(j.error || 'Request failed');
      log(`‚Üí ${cmd} (ok)`, 'out');
    } catch (err) {
      log(`‚úñ ${cmd} (${err.message})`, 'error');
    }
  }

  const qaRebootAll = document.getElementById('qaRebootAll');
  if (qaRebootAll) qaRebootAll.onclick = () => apiSend('REBOOT ALL');

  const qaVersionAll = document.getElementById('qaVersionAll');
  if (qaVersionAll) qaVersionAll.onclick = () => apiSend('VERSION ALL');

  const btnReadTracks = document.getElementById('btnReadTracks');
  if (btnReadTracks) {
    btnReadTracks.onclick = async () => {
      log('üìñ Reading stored track names...', 'info');
      try {
        const res = await fetch('/api/tracknames');
        const data = await res.json();
        if (data.ok && data.names) {
          for (let i = 0; i < 8 && i < data.names.length; i++) {
            const inputElement = document.getElementById('tname' + i);
            if (inputElement) {
              inputElement.value = data.names[i] || '';
            }
          }
          log(`‚úì Loaded ${data.names.length} track names from bridge`, 'out');
        } else {
          log('‚úó Failed to read track names', 'err');
        }
      } catch (err) {
        log(`‚úó Error: ${err.message}`, 'err');
      }
    };
  }

  // Legacy wired connection handler (removed - functionality now in device list)
  // const wiredConnectBtn = document.getElementById('btnWiredConnect');
  // if (wiredConnectBtn) wiredConnectBtn.onclick = async () => { ... };

  // Legacy WiFi handlers (removed)
  // const wifiConnectBtn = document.getElementById('btnWifiConnect');
  // if (wifiConnectBtn) wifiConnectBtn.onclick = async () => { ... };

  // Auto-scan WiFi networks (legacy - removed)
  // setTimeout(async () => { ... }, 2000); - no longer needed with modal system
});
</script>
</body>
</html>